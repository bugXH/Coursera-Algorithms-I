import edu.princeton.cs.algs4.*;
import java.lang.Math;
import java.util.ArrayList;

public class Board {
	private int[][] board;
	private int N;
    public Board(int[][] blocks) {  // construct a board from an N-by-N array of blocks
                                    // (where blocks[i][j] = block in row i, column j)
    	board = blocks;
    	N = board.length;
    	
    }
    
    public int dimension() {  // board dimension N
    	return N;
    }
    
    public int hamming() {  // number of blocks out of place
    	int n = 0;
    	for (int i = 0; i < N; i++) {
    		for (int j = 0; j < N; j++) {
    			if (i == N - 1 && j == N - 1) {
    				if (board[i][j] != 0) {
    					n++;
    				}
    			}
    			else if (board[i][j] != (j + 1 + i * N)) {
    				n++;
    			}
    		}
    	}
    	return n;
    }
    
    public int manhattan() {  // sum of Manhattan distances between blocks and goal
    	int n = 0;
    	int real_i, real_j;
    	for (int i = 0; i < N; i++) {
    		for (int j = 0; j < N; j++) {
    			if (board[i][j] == 0) {
    				n += (N - 1 - i) + (N - 1 - j);
    			}
    			else {
	    			real_i = board[i][j] / N;
	    			real_j = board[i][j] % N;
	    			n += Math.abs(real_i - i) + Math.abs(real_j - j);
    			}
    		}
    	}
    	return n;
    }
    
    public boolean isGoal() {   // is this board the goal board?
    	return hamming() == 0;
    }
    
    public Board twin() {   // a board that is obtained by exchanging any pair of blocks
    	int i = 0, j = 0;
    	int twinboard[][] = board.clone();
    	// blank cannot be exchanged
    	out: for (i = 0; i < N; i++) {
    		for (j = 0; j < N - 1; j++) {
    			if (board[i][j] != 0 && board[i][j + 1] != 0) {
    				break out;
    			}
    		}
    	}
    	// exchange the given one and the one to its right
    	int tmp = twinboard[i][j];
    	twinboard[i][j] = twinboard[i][j + 1];
    	twinboard[i][j + 1] = tmp;
    	return new Board(twinboard);
    	
    }
    
    public boolean equals(Object y) {      // does this board equal y?
    	// check reference
    	if (this == y) {
    		return true;
    	}
    	
    	// check class
    	if (y == null || this.getClass() != y.getClass()) {
    		return false;
    	}
    	
    	// check dimension
    	Board that = (Board)y;
    	if (this.N != that.N) {
    		return false;
    	}
    	
    	// check length
    	for (int i = 0; i < N; i++) {
    		if (this.board[i].length != that.board[i].length) {
    			return false;
    		}
    		
    		// check each element
    		for (int j = 0; j < N; j++) {
    			if (this.board[i][j] != that.board[i][j]) {
    				return false;
    			}
    		}
    	}
    	return true;
    }
    
    public Iterable<Board> neighbors() {   // all neighboring boards (those that can be reached in one move)
    	ArrayList<Board> neighbor = new ArrayList<Board>();
    	// get the indices of the blank block
    	int i = 0, j = 0;
    	out: for (i = 0; i < N; i++) {
    		for (j = 0; j < N; j++) {
    			if (board[i][j] == 0) {
    				break out;
    			}
    		}
    	}
    	
    	// 4 directions for one move in total: up down left right
    	// up
    	if (i != N - 1) {
    		int[][] newboard = board.clone();
    		// exchange
    		int tmp = newboard[i + 1][j];
    		newboard[i + 1][j] = newboard[i][j];
    		newboard[i][j] = tmp;
    		neighbor.add(new Board(newboard));
    	}
    	
    	//down
    	if (i != 0) {
    		int[][] newboard = board.clone();
    		// exchange
    		int tmp = newboard[i - 1][j];
    		newboard[i - 1][j] = newboard[i][j];
    		newboard[i][j] = tmp;
    		neighbor.add(new Board(newboard));
    	}
    	
    	//left
    	if (j != N - 1) {
    		int[][] newboard = board.clone();
    		// exchange
    		int tmp = newboard[i][j + 1];
    		newboard[i][j + 1] = newboard[i][j];
    		newboard[i][j] = tmp;
    		neighbor.add(new Board(newboard));
    	}
    	
    	//right
    	if (j != 0) {
    		int[][] newboard = board.clone();
    		// exchange
    		int tmp = newboard[i][j - 1];
    		newboard[i][j - 1] = newboard[i][j];
    		newboard[i][j] = tmp;
    		neighbor.add(new Board(newboard));
    	}
    	return neighbor;
    }
    
    public String toString() { // string representation of this board (in the output format specified below)
    	String str = "";
    	str += Integer.toString(N) + "\n";
    	for (int i = 0; i < N; i++) {
    		for (int j = 0; j < N; j++) {
    			if (j < N - 1) {
    				str += Integer.toString(board[i][j]) + "  ";
    			}
    			else {
    				str += Integer.toString(board[i][j]) + "\n";
    			}
    		}
    	}
    	return str;
    }

    public static void main(String[] args) { // unit tests (not graded)
    	// create initial board from file
        In in = new In(args[0]);
        int N = in.readInt();
        int[][] blocks = new int[N][N];
        for (int i = 0; i < N; i++)
            for (int j = 0; j < N; j++)
                blocks[i][j] = in.readInt();
        Board initial = new Board(blocks);
        StdOut.println(initial.toString());
        StdOut.println(initial.hamming());
        
        Board twin = initial.twin();
        StdOut.println(twin.toString());
    }
}
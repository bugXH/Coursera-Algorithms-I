
[3Sum](#3sum)

[Accounts Merge](#accounts-merge)

[Add And Search Word Data Structure Design](#add-and-search-word-data-structure-design)

[Add Binary](#add-binary)

[Add Digits](#add-digits)

[Alien Dictionary](#alien-dictionary)

[Average Of Levels In Binary Tree](#average-of-levels-in-binary-tree)

[Best Time To Buy And Sell Stock II](#best-time-to-buy-and-sell-stock-ii)

[Best Time To Buy And Sell Stock With Transaction Fee](#best-time-to-buy-and-sell-stock-with-transaction-fee)

[Best Time to Buy and Sell Stock](#best-time-to-buy-and-sell-stock)

[Binary Search Tree Iterator](#binary-search-tree-iterator)

[Binary Tree Level Order Traversal](#binary-tree-level-order-traversal)

[Binary Tree Paths](#binary-tree-paths)

[Binary Tree Vertical Order Traversal](#binary-tree-vertical-order-traversal)/

[Boundary Of Binary Tree](#boundary-of-binary-tree)

[Brick Wall](#brick-wall)

[Clone Graph](#clone-graph)

[Combination Sum III](#combination-sum-iii)

[Combination Sum II](#combination-sum-ii)

[Combination Sum IV](#combination-sum-iv)

[Combination Sum](#combination-sum)

[Construct The Rectangle](#construct-the-rectangle)

[Contiguous Array](#contiguous-array)

[Continuous Subarray Sum](#continuous-subarray-sum)

[Count And Say](#count-and-say)

[Course Schedule II](#course-schedule-ii)

[Decode Ways II](#decode-ways-ii)

[Decode Ways](#decode-ways)

[Design Search Autocomplete System](#design-search-autocomplete-system)

[Diameter Of Binary Tree](#diameter-of-binary-tree)

[Distinct Subsequences](#distinct-subsequences)

[Encode And Decode Tinyurl](#encode-and-decode-tinyurl)

[Excel Sheet Column Title](#excel-sheet-column-title)

[Exclusive Time Of Functions](#exclusive-time-of-functions)

[Expression Add Operators](#expression-add-operators)

[Find Maximim Sum With Size K](#find-maximim-sum-with-size-k)

[Find The Celebrity](#find-the-celebrity)

[First Bad Version](#first-bad-version)

[Flatten Nested List Iterator](#flatten-nested-list-iterator)

[Graph Valid Tree](#graph-valid-tree)

[Group Anagrams](#group-anagrams)

[H Index II](#h-index-ii)

[H Index](#h-index)

[Hamming Distance](#hamming-distance)

[Implement Strstr](#implement-strstr)

[Implement Trie Prefix Tree](#implement-trie-prefix-tree)

[Increasing Triplet Subsequence](#increasing-triplet-subsequence)

[Inorder Successor In Bst](#inorder-successor-in-bst)

[Insert Delete Getrandom O1](#insert-delete-getrandom-o1)

[Insert Interval](#insert-interval)

[Integer To English Words](#integer-to-english-words)

[Kth Largest Element In An Array](#kth-largest-element-in-an-array)

[LRU Cache](#lru-cache)

[Largest Plus Sign](#largest-plus-sign)

[Letter Combinations of a Phone Number](#letter-combinations-of-a-phone-number)

[Linked List Random Node](#linked-list-random-node)

[Longest Consecutive Sequence](#longest-consecutive-sequence)

[Longest Continuous Increasing Subsequence](#longest-continuous-increasing-subsequence)

[Lowest Common Ancestor Of A Binary Tree](#lowest-common-ancestor-of-a-binary-tree)

[Maximal Rectangle](#maximal-rectangle)

[Maximal Square](#maximal-square)

[Maximum Product Subarray](#maximum-product-subarray)

[Maximum Size Subarray Sum Equals K](#maximum-size-subarray-sum-equals-k)

[Maximum Subarray](#maximum-subarray)

[Maximum Sum of 3 Non-Overlapping Subarrays](#maximum-sum-of-3-non-overlapping-subarrays)

[Maximum Swap](#maximum-swap)

[Meeting Rooms II](#meeting-rooms-ii)

[Meeting Rooms](#meeting-rooms)

[Merge Intervals](#merge-intervals)

[Merge K Sorted Lists](#merge-k-sorted-lists)

[Merge Sorted Array](#merge-sorted-array)

[Minimum Size Subarray Sum](#minimum-size-subarray-sum)

[Minimum Window Substring](#minimum-window-substring)

[Move Zeroes](#move-zeroes)

[Multiply Strings](#multiply-strings)

[Next Permutation](#next-permutation)

[Number Of Corner Rectangles](#number-of-corner-rectangles)

[Number of Islands](#number-of-islands)

[Number of Longest Increasing Subsequence](#number-of-longest-increasing-subsequence)

[One Edit Distance](#one-edit-distance)

[Paint House II](#paint-house-ii)

[Palindrome Linked List](#palindrome-linked-list)

[Palindromic Substrings](#palindromic-substrings)

[Permutations II](#permutations-ii)

[Permutations](#permutations)

[Populating Next Right Pointers in Each Node II](#populating-next-right-pointers-in-each-node-ii)

[Populating Next Right Pointers in Each Node](#populating-next-right-pointers-in-each-node)

[Powx N](#powx-n)

[Prefix And Suffix Search](#prefix-and-suffix-search)

[Previous Permutation](#previous-permutation)

[Product Of Array Except Self](#product-of-array-except-self)

[Random Pick Index](#random-pick-index)

[Read N Characters Given Read4 Ii Call Multiple Times](#read-n-characters-given-read4-ii-call-multiple-times)

[Read N Characters Given Read4](#read-n-characters-given-read4)

[Regular Expression Matching](#regular-expression-matching)

[Remove Duplicates From Sorted Array II](#remove-duplicates-from-sorted-array-ii)

[Remove Duplicates From Sorted Array](#remove-duplicates-from-sorted-array)

[Remove Invalid Parentheses](#remove-invalid-parentheses)

[Reverse Linked List](#reverse-linked-list)

[Reverse Nodes In K Group](#reverse-nodes-in-k-group)

[Roman To Integer](#roman-to-integer)

[Search in Rotated Sorted Array II](#search-in-rotated-sorted-array-ii)

[Search in Rotated Sorted Array](#search-in-rotated-sorted-array)

[Serialize and Deserialize Binary Tree](#serialize-and-deserialize-binary-tree)

[Shortest Unsorted Continuous Subarray](#shortest-unsorted-continuous-subarray)

[Simple Encode String Shorter](#simple-encode-string-shorter)

[Simplify Path](#simplify-path)

[Sort Colors](#sort-colors)

[Sparse Matrix Multiplication](#sparse-matrix-multiplication)

[Split Array Largest Sum](#split-array-largest-sum)

[Super Pow](#super-pow)

[Sqrt x](#sqrt-x)

[Subsets II](#subsets-ii)

[Subsets](#subsets)

[Subtree Of Another Tree](#subtree-of-another-tree)

[Sum Of Left Leaves](#sum-of-left-leaves)

[Summary Ranges](#summary-ranges)

[Symmetric Tree](#symmetric-tree)

[Target Sum](#target-sum)

[Task Scheduler](#task-scheduler)

[Text Justification](#text-justification)

[Total Hamming Distance](#total-hamming-distance)

[Two Sum Iv Input Is A Bst](#two-sum-iv-input-is-a-bst)

[Two Sum](#two-sum)

[Valid Palindrome II](#valid-palindrome-ii)

[Valid Palindrome](#valid-palindrome)

[Valid Parentheses](#valid-parentheses)

[Validate Binary Search Tree](#valid-binary-search-tree)

[Walls and Gates](#walls-and-gates)

[Wildcard Matching](#wildcard-matching)

[Word Break II](#word-break-ii)

[Word Break](#word-break)

[Word Ladder](#word-ladder)

[Word Search](#word-search)]


## Subsets

[Problem URL](https://leetcode.com/problems/subsets/)

Description:

> Given a set of distinct integers, nums, return all possible subsets.
> 
> Note: The solution set must not contain duplicate subsets.
> 
> For example,
> If nums = [1,2,3], a solution is:
> 
> [
>   [3],
>   [1],
>   [2],
>   [1,2,3],
>   [1,3],
>   [2,3],
>   [1,2],
>   []
> ]

Solution:
Time O(2 ^ n)
Space O(n), max depth is n
```java
public List<List<Integer>> subsets(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    backtrack(nums, result, new ArrayList<>(), 0);
    return result;
}

private void backtrack(int[] nums,
                       List<List<Integer>> result,
                       List<Integer> curr, int pos) {
    result.add(new ArrayList<>(curr));
    for (int i = pos; i < nums.length; i++) {
        curr.add(nums[i]);
        backtrack(nums, result, curr, i + 1);
        curr.remove(curr.size() - 1);
    }
}
```


## Subsets II

[Problem URL](https://leetcode.com/problems/subsets-ii)

Description:

> Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
> 
> Note: The solution set must not contain duplicate subsets.
> 
> For example,
> If nums = [1,2,2], a solution is:
> 
> [
>   [2],
>   [1],
>   [1,2,2],
>   [2,2],
>   [1,2],
>   []
> ]


Solution:
Classic backtracking, time O(2 ^ n), there are at most 2 ^ n subsets, the operation (res.add()) will be executed at most 2 ^ n times.
Space O(n)
```java
public List<List<Integer>> subsetsWithDup(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList<>();
    backtrack(nums, res, new ArrayList<>(), 0);
    return res;
}

private void backtrack(int[] nums, List<List<Integer>> res, List<Integer> curr, int start) {
    res.add(new ArrayList<>(curr));
    for (int i = start; i < nums.length; i++)
        if (i == start || nums[i] != nums[i - 1]) {
            curr.add(nums[i]);
            backtrack(nums, res, curr, i + 1);
            curr.remove(curr.size() - 1);
        }
}
```


## Inorder Successor In Bst

[Problem URL](https://leetcode.com/problems/inorder-successor-in-bst)

Description:

> Given a binary search tree and a node in it, find the in-order successor of that node in the BST.
> 
> Note: If the given node has no in-order successor in the tree, return null. 

Solution1:
Recursive time O(h), space O(h), h is the height of the tree
For balanced bst, h = logn
Worst case, h = n
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    if (root == null)
        return null;
    // the successor can either be p's parent or the smallest node in p's right branch.
    if (root.val <= p.val) {
        // current root may be candidate
        // go to right subtree to narrow down scope
        return inorderSuccessor(root.right, p);
    } else {
        // root > p
        // current root is either p's parent or a node in p's right branch.
        // If it's p's parent node, p = root's left child, here are two scenarios:
        // 1. p doesn't have right child, in this case,
        // the recursion will eventually return null,
        // so p's parent is the successor
        // 2. p has right child,
        // then the recursion will return the smallest node in the right sub tree,
        // and that will be the answer.
        // 
        // If it's p's right child, there are two scenarios:
        // 1. the right child has left sub tree,
        // eventually the smallest node from the left sub tree will be the answer
        // 2. the right child has no left sub tree, the recursion will return null,
        // then the right child (root) is our answer.
        TreeNode left = inorderSuccessor(root.left, p);
        return left != null ? left : root;
    }
}
```


Extra: finding predecessor
```java
public TreeNode inorderPredecessor(TreeNode root, TreeNode p) {
    if (root == null)
        return null;
    // the predecessor can either be p's parent or the largest node in p's left branch.
    if (root.val >= p.val) {
        // current root may be candidate
        // go to left subtree to narrow down scope
        return inorderPredecessor(root.left, p);
    } else {
        // root < p
        // root may either be p's parent or a node in p's left subtree
        // if root = p's parent, p is right child of root, two cases:
        // 1. p has no left child, eventually return null, then the root(parent) is the answer
        // 2. p has left child, eventually return the largest one in right subtree
        // if root is p's left child, two cases:
        // 1. left child has right subtree
        // eventually the largest one will be returned
        // 2. left child has no right subtree
        // then itself will be returned
        TreeNode right = inorderPredecessor(root.right, p);
        return (right != null) ? right : root;
  }
}
```

Solution2:
Iterative, time O(h), space O(1)
```java
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    TreeNode succ = null;
    // the successor can either be p's parent or the smallest node in p's right branch.
    while (root != null)
        if (p.val < root.val) {
            // root could be candidate, mark it
            // go left to narrow down scope
            succ = root;
            root = root.left;
        } else {
            // p >= root
            // find larger root
            root = root.right;
        }
    return succ;
}
```

Extra: find predecessor
```java
public TreeNode inorderPredecessor(TreeNode root, TreeNode p) {
    TreeNode pre = null;
    // the predecessor can either be p's parent or the largest node in p's left branch.
    while (root != null)
        if (p.val <= root.val) {
            // root is on right subtree of p,
            // go left
            root = root.left;
        } else {
            pre = root;
            root = root.right;
        }
    return pre;
}
```


## Clone Graph

[Problem URL](https://leetcode.com/problems/clone-graph)

Description:

> Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
> 
> 
> OJ's undirected graph serialization:
> Nodes are labeled uniquely.
> 
> We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.
> As an example, consider the serialized graph {0,1,2#1,2#2,2}.
> 
> The graph has a total of three nodes, and therefore contains three parts as separated by #.
> 
> First node is labeled as 0. Connect node 0 to both nodes 1 and 2.
> Second node is labeled as 1. Connect node 1 to node 2.
> Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.
> Visually, the graph looks like the following:
> 
>        1
>       / \
>      /   \
>     0 --- 2
>          / \
>          \_/

Solution1:
Iterative dfs
Time O(|V| + |E|)
Space O(|V| + |E|), nonrecursive, stack use O(|E|), map uses O(|V|)
```java
/**
 * Definition for undirected graph.
 * class UndirectedGraphNode {
 *     int label;
 *     List<UndirectedGraphNode> neighbors;
 *     UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList<UndirectedGraphNode>(); }
 * };
 */
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null)
        return null;
    // key is original node
    // value is cloned node
    HashMap<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap<>();
    Stack<UndirectedGraphNode> stack = new Stack<>();
    UndirectedGraphNode copy = new UndirectedGraphNode(node.label);
    map.put(node, copy);
    stack.push(node);
    // dfs
    while (!stack.isEmpty()) {
        UndirectedGraphNode curr = stack.pop();
        for (UndirectedGraphNode connected: curr.neighbors) {
            if (!map.containsKey(connected)) {
                copy = new UndirectedGraphNode(connected.label);
                map.put(connected, copy);
                stack.push(connected);
            }
            map.get(curr).neighbors.add(map.get(connected));
        }
    }
    return map.get(node);
}
```

Solution2:
Recursive DFS
Time O(|V| + |E|)
Space O(|V|)
```java
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    HashMap<Integer, UndirectedGraphNode> map = new HashMap<Integer, UndirectedGraphNode>();
    return dfs(node, map);
}

private UndirectedGraphNode dfs(UndirectedGraphNode node, HashMap<Integer, UndirectedGraphNode> map) {
    if (node == null)
        return null;
    if (map.containsKey(node.label)) {
        return map.get(node.label);
    } else {
        UndirectedGraphNode clone = new UndirectedGraphNode(node.label);
        map.put(node.label, clone);
        for (int i = 0; i < node.neighbors.size(); i++) {
            clone.neighbors.add(dfs(node.neighbors.get(i), map));
        }
        return clone;
    }
}
```


Solution3:
BFS
Time O(|V| + |E|)
Space O(|V|)
```java
public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) {
    if (node == null) return null;
    // origin node : copied node
    Map<UndirectedGraphNode, UndirectedGraphNode> map = new HashMap(); 
    UndirectedGraphNode copy = new UndirectedGraphNode(node.label);
    map.put(node, copy);
    // origin nodes
    Queue<UndirectedGraphNode> q = new ArrayDeque(); 
    q.add(node);
    // bfs traverse graph
    while (!q.isEmpty()) {
        UndirectedGraphNode cur = q.poll();
        // all neighbors of current origin node
        for (UndirectedGraphNode neighbor : cur.neighbors) {
            // if the origin node is not visited
            if (!map.containsKey(neighbor)) {
                map.put(neighbor, new UndirectedGraphNode(neighbor.label));
                // to avoid loop, we just add the unvisited node to queue
                q.offer(neighbor);
            }
            // add neighbors to the copied node
            // copied node: map.get(cur) -> copied node of cur
            // neighbors: map.get(neighbor) -> copied node of neighbor
            map.get(cur).neighbors.add(map.get(neighbor));
        }
    }
    return copy;
}
```


## Insert Interval

[Problem URL](https://leetcode.com/problems/insert-interval)

Description:

> Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
> 
> You may assume that the intervals were initially sorted according to their start times.
> 
> Example 1:
> Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].
> 
> Example 2:
> Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].
> 
> This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].


Solution1:
Time O(n), space O(1)
```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
    int i = 0;
    List<Interval> res = new ArrayList<>();
    // add all intervals that ends before the new interval starts
    while (i < intervals.size() && intervals.get(i).end < newInterval.start)
        res.add(intervals.get(i++));
    // merge all overlapping intervals
    while (i < intervals.size() && intervals.get(i).start <= newInterval.end) {
        newInterval.start = Math.min(intervals.get(i).start, newInterval.start);
        newInterval.end = Math.max(intervals.get(i).end, newInterval.end);
        i++;
    }
    res.add(newInterval);
    // add the rest
    while (i < intervals.size())
        res.add(intervals.get(i++));
    return res;
}
```


Solution2:
One pass, time O(n), space O(1)
```java
public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
    List<Interval> res = new ArrayList<>();
    for (Interval curr : intervals) {
        // new interval is added or non-overlapping but ends before new interval starts
        if (newInterval == null || curr.end < newInterval.start)
            res.add(curr);
        else if (curr.start > newInterval.end) {
            // current interval starts after new interval
            // add new interval first
            res.add(newInterval);
            res.add(curr);
            // mark new interval is added
            newInterval = null;
        } else {
            newInterval.start = Math.min(curr.start, newInterval.start);
            newInterval.end = Math.max(curr.end, newInterval.end);
        }
    }
    if (newInterval != null)
        res.add(newInterval);
    return res;
}
```


## Kth Largest Element In An Array

[Problem URL](https://leetcode.com/problems/kth-largest-element-in-an-array)

Description:

> Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
> For example,
> Given [3,2,1,5,6,4] and k = 2, return 5.
> 
> Note: 
> You may assume k is always valid, 1 â‰¤ k â‰¤ array's length.

Solution1:
Quick selection
Time O(n) on avg
Space O(logn)
```java
public int findKthLargest(int[] a, int k) {
    int n = a.length;
    int idx = quickSelect(a, 0, n - 1, n - k + 1);
    return a[idx];
}

// return the index of the kth smallest number
int quickSelect(int[] nums, int lo, int hi, int k) {
    // use quick sort's idea
    // put nums that are <= pivot to the left
    // put nums that are  > pivot to the right
    int pivot = nums[hi];
    int currIdx = lo;
    for (int i = lo; i < hi; i++)
        if (nums[i] < pivot) {
            swap(nums, currIdx, i);
            currIdx++;
        }
    swap(nums, currIdx, hi);

    // count the nums that are <= pivot from lo
    int m = currIdx - lo + 1;

    // pivot is the one!
    if (m == k)
        return currIdx;
    // pivot is too big, so it must be on the left
    else if (m > k)
        return quickSelect(nums, lo, currIdx - 1, k);
    // pivot is too small, so it must be on the right
    else
        return quickSelect(nums, currIdx + 1, hi, k - m);
}

private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
```

Solution2:
Another quick select
```java
// Quickselection
/*
 The idea of the quick select is quite simple:
 just like with quicksort, select a random element from the list,
 and place every item that is smaller to the first half of the array,
 and every element that is equal to or greater than the pivot, in the second half
 */
// Time O(n), avg
// Space O(logn)
public int findKthLargest(int[] nums, int k) {
    // find (n - k) + 1th smallest number
    // 0-indexed, 0...k, so k + 1 th smallest
    k = nums.length - k;
    int lo = 0;
    int hi = nums.length - 1;
    while (lo < hi) {
        int j = partition(nums, lo, hi);
        // pivot is too small
        if (j < k) {
            lo = j + 1;
        } else if (j > k) {
            // pivot is too large
            hi = j - 1;
        } else {
            break;
        }
    }
    return nums[k];
}

private int partition(int[] a, int lo, int hi) {
    // essentially a quick sort 
    int i = lo;
    int j = hi;
    // choose a[lo] as pivot
    // move all <= pivot to left
    // move all >= pivot to right
    while (i < j) {
        while (i < hi && (a[i] <= a[lo]))
            i++;
        while (j > lo && (a[lo] <= a[j]))
            j--;
        if (i < j) {
            swap(a, i, j);
        }
    }
    // move pivot to the meeting point
    swap(a, lo, j);
    // return index of the pivot
    return j;
}

private void swap(int[] a, int i, int j) {
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}
```


Solution3:
Min heap, largest one is in the tail of the queue
while kth largest (min in the heap) is in the head of the queue
Time O(nlogk)
Space O(k)
```java
public int findKthLargest(int[] nums, int k) {
    if (nums == null || nums.length == 0 || k <= 0) {
        return Integer.MAX_VALUE;
    }
    PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
    for (int n: nums) {
        pq.offer(n);
        if (pq.size() > k) {
            pq.poll();
        }
    }
    return pq.peek();
}
```



## Word Break

[Problem URL](https://leetcode.com/problems/word-break/)

Description:

> Given a string s and a dictionary of words dict, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
>
> For example, given
> s = "leetcode",
> dict = ["leet", "code"].
> 
> Return true because "leetcode" can be segmented as "leet code".

Solution:
```java
// Time O(n ^ 2)
// Space O(1)
public boolean wordBreak(String s, List<String> wordDict) {
    Set<String> wordDictSet = new HashSet<>(wordDict);
    int n = s.length();
    int maxLen = 0;
    for (String word: wordDictSet) {
        int currLen = word.length();
        if (currLen > maxLen) {
            maxLen = currLen;
        }
    }
    // dp[i] = s[0..i - 1] can be break down into words
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    for (int i = 1; i < n + 1; i++) {
        for (int j = Math.max(0, i - maxLen); j < i; j++) {
            if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                dp[i] = true;
            }
        }
    }
    return dp[n];
}
```


## Word Break II

[Problem URL](https://leetcode.com/problems/word-break-ii/)

Description:

> Given a string s and a dictionary of words dict, add spaces in s to construct a sentence where each word is a valid dictionary word.
> 
> Return all such possible sentences.
> 
> For example, given
> s = "catsanddog",
> dict = ["cat", "cats", "and", "sand", "dog"].
> 
> A solution is ["cats and dog", "cat sand dog"].

Solution:
```java
// Time O(len(wordDict) ^ len(s / minWordLenInDict)), because thereâ€™re len(wordDict) possibilities for each cut
// or O(2 ^ n), consider the input â€œaaaaaaâ€,
// with wordDict = [â€œaâ€, â€œaaâ€, â€œaaaâ€, â€œaaaaâ€, â€œaaaaaâ€, â€œaaaaaâ€].
// Every possible partition is a valid sentence, and there are 2^n-1 such partitions. 
// Space O(2 ^ n), every partition is in memory 
public List<String> wordBreak(String s, List<String> wordDict) {
    Set<String> wordDictSet = new HashSet<>(wordDict);
    Map<String, List<String>> map = new HashMap<>();
    return dfs(s, wordDictSet, map);
}


// HashMap<String,List<String>> map = new HashMap<String,List<String>>();
public List<String> dfs(String s, Set<String> wordDict, Map<String, List<String>> map) {
    List<String> res = new ArrayList<String>();
    if (s == null || s.length() == 0) {
        return res;
    }
    if (map.containsKey(s)) {
        return map.get(s);
    }
    if (wordDict.contains(s)) {
        res.add(s);
    }
    for (int i = 1 ; i < s.length() ; i++) {
        String t = s.substring(i);
        if (wordDict.contains(t)) {
            List<String> temp = dfs(s.substring(0, i) , wordDict, map);
            if (temp.size() != 0) {
                for (int j = 0 ; j < temp.size() ; j++) {
                    res.add(temp.get(j) + " " + t);
                }
            }
        }
    }
    map.put(s , res);
    return res;
}
```


## Product Of Array Except Self

[Problem URL](https://leetcode.com/problems/product-of-array-except-self)

Description:

> Given an array of n integers where n > 1, nums, return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].
> 
> Solve it without division and in O(n).
> 
> For example, given [1,2,3,4], return [24,12,8,6].
> 
> Follow up:
> Could you solve it with constant space complexity? (Note: The output array does not count as extra space for the purpose of space complexity analysis.)


Solution:
```java
// time O(n)
// space O(1)
public int[] productExceptSelf(int[] nums) {
    // product for each index contains two parts
    // left and right
    int n = nums.length;
    int[] res = new int[n];
    Arrays.fill(res, 1);
    int left = 1, right = 1;
    for (int i = 0, j = n - 1; i < n; i++, j--) {
        res[i] *= left;
        left *= nums[i];
        res[j] *= right;
        right *= nums[j];
    }
    return res;
}
```


## Maximum Swap

[Problem URL](https://leetcode.com/problems/maximum-swap)

Description:

> Given a non-negative integer, you could swap two digits at most once to get the maximum valued number. Return the maximum valued number you could get.
> 
> Example 1:
> Input: 2736
> Output: 7236
> Explanation: Swap the number 2 and the number 7.
> Example 2:
> Input: 9973
> Output: 9973
> Explanation: No swap.
> Note:
> The given number is in the range [0, 108]

Solution:
```java
// time O(n), n is length of the num
// space O(n)
public int maximumSwap(int num) {
    char[] digits = String.valueOf(num).toCharArray();
    char maxDigit = '0';
    int leftIdx = -1, rightIdx = -1, maxIdx = -1;
    for (int i = digits.length - 1; i >= 0; i--) {
        // find max digit and its index, backwards
        if (digits[i] > maxDigit) {
            maxDigit = digits[i];
            maxIdx = i;
            continue;
        }
        // find position to swap, if current digit is not the largest one
        if (digits[i] < maxDigit) {
            leftIdx = i;
            rightIdx = maxIdx;
        }
    }
    // check if num is already the largest
    if (leftIdx == -1)
        return num;
    // swap
    char tmp = digits[leftIdx];
    digits[leftIdx] = digits[rightIdx];
    digits[rightIdx] = tmp;
    return Integer.valueOf(new String(digits));
}
```


## Merge Sorted Array

[Problem URL](https://leetcode.com/problems/merge-sorted-array)

Description:

> Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
> 
> Note:
> You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

Solution1:
```java
// Time o(m + n)
// Space O(1)
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j])
            nums1[k--] = nums1[i--];
        else
            nums1[k--] = nums2[j--];
    }
    while (j >= 0)
        nums1[k--] = nums2[j--];
}
```


Solution2:
```java
// Time O(n)
// Space O(1)
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int len = m + n;
    while (n > 0)
        nums1[--len] = (m == 0 || nums1[m - 1] < nums2[n - 1]) ? nums2[--n] : nums1[--m];
}
```


## Sort Colors

[Problem URL](https://leetcode.com/problems/sort-colors)

Description:

> Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.
> 
> Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
> 
> Note:
> You are not suppose to use the library's sort function for this problem.
> 
> click to show follow up.
> 
> Follow up:
> A rather straight forward solution is a two-pass algorithm using counting sort.
> First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
> 
> Could you come up with an one-pass algorithm using only constant space?


Solution:
Basic idea is to move all 0 to left and all 2 to right. Be careful with the index of the current number to operate on.
Time O(n), space O(1)
```java
public void sortColors(int[] nums) {
    if (nums == null || nums.length < 2)
        return;
    // low is the index for '0's
    // high is the index for '1's
    int low = 0, high = nums.length - 1;
    // i is the index to operate on
    for (int i = low; i <= high;) {
        if (nums[i] == 0) {
            // swap 0 to left
            int temp = nums[i];
            nums[i] = nums[low];
            nums[low] = temp;
            low++;
            i++;
        } else if (nums[i] == 2) {
            // swap 2 to right
            int temp = nums[i];
            nums[i] = nums[high];
            nums[high] = temp;
            // the one swapped from the right may not be in order
            // so don't increment i
            high--;
        } else {
            i++;
        }
    }
}
```


## Search in Rotated Sorted Array

[Problem URL](https://leetcode.com/problems/search-in-rotated-sorted-array/)

Description:

> Suppose a sorted array is rotated at some pivot unknown to you beforehand.
> 
> (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
> 
> You are given a target value to search. If found in the array return its index, otherwise return -1.
> 
> You may assume no duplicate exists in the array.

Solution1:
Time O(logn), space O(1)
```java
public int search(int[] nums, int target) {
    if (nums.length == 0 || nums == null) {
        return -1;
    }
    int minIdx = getMinIdx(nums);
    if (nums[minIdx] == target) {
        return minIdx;
    }
    int n = nums.length - 1;
    // if target is in the area that is sorted
    // then the beginning should be the smallest
    // otherwise starts from 0
    int l = target <= nums[n] ? minIdx : 0;
    // if target is in the area that is sorted
    // then the end should be the last one
    // otherwise the end should be the smallest
    int r = target <= nums[n] ? n : minIdx;
    while (l <= r) {
        int m = (l + r) / 2;
        if (nums[m] == target) {
            return m;
        } else if (nums[m] > target) {
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}

private int getMinIdx(int[] nums) {
    int l = 0, r = nums.length - 1;
    while (l < r) {
        int m = (l + r) / 2;
        // if m ~ r is not sorted,
        // then shrink the left boundary to find the sorted area
        if (nums[m] > nums[r]) {
            l = m + 1;
        } else {
            // if m ~ r is sorted, then shrink the range
            r = m;
        }
    }
    return l;
}
```

Solution2:
```java
// Time O(logn)
// Space O(1)
public int search(int[] nums, int target) {
    if (nums.length == 0 || nums == null)
        return -1;
    int lo = 0;
    int hi = nums.length - 1;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        if (nums[mid] == target)
            return mid;
        if (nums[lo] <= nums[mid]) {
             if (target < nums[mid] && target >= nums[lo])
                // if lo..mid is sorted
                hi = mid - 1;
             else
                // go search the other half
                lo = mid + 1;
        } else if (nums[mid] <= nums[hi]) {
            if (target > nums[mid] && target <= nums[hi])
                // if mid..hi is sorted
                lo = mid + 1;
             else
                // go search the other half
                hi = mid - 1;
        }
    }
    return -1;
}
```


## Search in Rotated Sorted Array II

[Problem URL](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)

Description:

> Follow up for "Search in Rotated Sorted Array":
> What if duplicates are allowed?
> 
> Would this affect the run-time complexity? How and why?
> 
> Write a function to determine if a given target is in the array.

Solution1:
```java
// Time O(n), space O(1)
public boolean search(int[] nums, int target) {
    if (nums.length == 0 || nums == null)
        return false;
    int lo = 0, hi = nums.length - 1, mid;
    while(lo <= hi) {
        mid = lo + (hi - lo) / 2;
        if (nums[mid] == target)
            return true;
        // the only difference from the first one, trickly case, just updat lo and hi
        if ((nums[lo] == nums[mid]) && (nums[hi] == nums[mid])) {
            lo++;
            hi--;
        } else if (nums[lo] <= nums[mid]) {
            if ((nums[lo] <= target) && (nums[mid] > target))
                hi = mid - 1;
            else
                lo = mid + 1; 
        }
        else {
            if ((nums[mid] < target) && (nums[hi] >= target))
                lo = mid + 1;
            else
                hi = mid - 1;
        }
    }
    return false;
}
```

Solution2:
Time O(n), space O(1)
```java
public boolean search(int[] nums, int target) {
    if (nums.length == 0 || nums == null) {
        return false;
    }
    int l = 0, r = nums.length - 1;
    while (l <= r) {
        int m = (l + r) / 2;
        if (nums[m] == target) {
            return true;
        } else if (nums[m] > nums[l]) {
        // l ~ m sorted
            if (target >= nums[l] && target < nums[m]) {
                r = m - 1;
            } else {
                l = m + 1;
            }
        } else if (nums[m] < nums[l]) {
        // m ~ r sorted
            if (target > nums[m] && target <= nums[r]) {
                l = m + 1;
            } else {
                r = m - 1;
            }
        } else {
            l++;
        }
    }
    return false;
}
```


## LRU Cache

[Problem URL](https://leetcode.com/problems/lru-cache)

Description:

> Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.
> 
> get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
> put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.
> 
> Follow up:
> Could you do both operations in O(1) time complexity?
> 
> Example:
> 
> LRUCache cache = new LRUCache( 2 /* capacity */ );
> 
> cache.put(1, 1);
> cache.put(2, 2);
> cache.get(1);       // returns 1
> cache.put(3, 3);    // evicts key 2
> cache.get(2);       // returns -1 (not found)
> cache.put(4, 4);    // evicts key 1
> cache.get(1);       // returns -1 (not found)
> cache.get(3);       // returns 3
> cache.get(4);       // returns 4

Solution1:
```java
// Time: both O(1)
// Space O(n)
public class LRUCache {
    int size;
    int capacity;
    LinkedHashMap<Integer, Integer> LRU;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        size = 0;
        LRU = new LinkedHashMap<Integer, Integer>();
    }
    
    public int get(int key) {
        if (LRU.containsKey(key)) {
            int val = LRU.get(key);
            // change the order, need to remove first and then put, thus the order will change
            LRU.remove(key);
            LRU.put(key, val);
            return val;
        }
        return -1;
    }
    
    public void set(int key, int value) {
        // if key already exists, remove it first
        if (LRU.containsKey(key)) {
            LRU.remove(key);
            size--;
        }
        
        // if reach capacity limit, remove the oldest key
        if (size == capacity) {
            // order of keySet() in LinkedHashMap is guaranteed in order
            LRU.remove(LRU.keySet().iterator().next());
            size--;
        }
        LRU.put(key, value);
        size++;
    }
}
```


Solution2:
```java
class LRUCache {
    // Time: all O(1)
    // Space O(n)
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
    }

    /**
     * Always add the new node right after head;
     */
    private void addNode(DLinkedNode node){
        node.prev = head;
        node.next = head.next;

        head.next.prev = node;
        head.next = node;
    }

    /**
     * Remove an existing node from the linked list.
     */
    private void removeNode(DLinkedNode node){
        DLinkedNode prev = node.prev;
        DLinkedNode next = node.next;

        prev.next = next;
        next.prev = prev;
    }

    /**
     * Move certain node in between to the head.
     */
    private void moveToHead(DLinkedNode node){
        removeNode(node);
        addNode(node);
    }

    // pop the current tail. 
    private DLinkedNode popTail(){
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }

    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
    private int count;
    private int capacity;
    private DLinkedNode head, tail;

    public LRUCache(int capacity) {
        this.capacity = capacity;
        
        // mark the boundaries
        head = new DLinkedNode();
        head.prev = null;

        tail = new DLinkedNode();
        tail.next = null;

        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null)
            return -1; // should raise exception here.
        // move the accessed node to the head;
        moveToHead(node);
        return node.value;
    }


    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            DLinkedNode newNode = new DLinkedNode();
            newNode.key = key;
            newNode.value = value;
            cache.put(key, newNode);
            addNode(newNode);
            if (cache.size() > capacity) {
                // pop the tail
                DLinkedNode tail = popTail();
                cache.remove(tail.key);
            }
        } else {
            // update the value.
            node.value = value;
            moveToHead(node);
        }
    }
}

/*
add erase(key) and getMostRecentKey()
    public void erase(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null)
            return;
        cache.remove(key);
        removeNode(node);
    }
    
    public int getMostRecentKey() {
        if (cache.isEmpty() || head.next == tail)
            return -1;
        return head.next.key;
    }
*/

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```


## Roman To Integer

[Problem URL](https://leetcode.com/problems/roman-to-integer)

Description:

> Given a roman numeral, convert it to an integer.
> 
> Input is guaranteed to be within the range from 1 to 3999.

```java
// Time O(n)
// Space O(1)
public int romanToInt(String s) {
    String roman = "IVXLCDM";
    int[] val = {1, 5, 10, 50, 100, 500, 1000};
    int prevIdx = -1;
    int num = 0;
    int currIdx;
    for (int i = s.length() - 1; i >= 0; i--) {
        currIdx = roman.indexOf(s.charAt(i));
        if (currIdx < prevIdx) {
            num -= val[currIdx];
        } else {
            num += val[currIdx];
        }
        prevIdx = currIdx;
    }
    return num;
}
```


## Reverse Linked List

[Problem URL](https://leetcode.com/problems/reverse-linked-list)

Description:

> Reverse a singly linked list.

Solution1:
Recursive
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
// Time O(n)
// Space O(n)
public ListNode reverseList(ListNode head) {
   if (head == null || head.next == null)
       return head;
    ListNode newHead = reverseList(head.next);
    head.next.next = head;
    head.next = null;
    return newHead;
}
```

Solution2:
```java
// Time O(n)
// Space O(1)
public ListNode reverseList(ListNode head) {
    ListNode newHead = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = newHead;
        newHead = head;
        head = next;
    }
    return newHead;
}
```


## Word Search

[Problem URL](https://leetcode.com/problems/word-search/)

Description:

> Given a 2D board and a word, find if the word exists in the grid.
> 
> The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
> 
> For example,
> Given board =
> 
> [
>   ['A','B','C','E'],
>   ['S','F','C','S'],
>   ['A','D','E','E']
> ]
> word = "ABCCED", -> returns true,
> word = "SEE", -> returns true,
> word = "ABCB", -> returns false.


Solution:
Backtracking:
Version 1
Time O(m * n * 4 ^ k), m, n = dims of board, k = word.length()
max depth is 4 ^ k, recursively traversing the 4 adjacent cells at each step.
Space O(4 ^ k)
```java
public boolean exist(char[][] board, String word) {
    if (word == null || word.length() == 0) return true;
    if (board == null
        || board.length == 0
        || board[0].length == 0) return false;
    boolean[][] used = new boolean[board.length][board[0].length];
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            if (backtrack(board, used, i, j, 0, word))
                return true;
        }
    }
    return false;
}

private boolean backtrack(char[][] board,
                          boolean[][] used,
                          int i,
                          int j,
                          int index,
                          String word) {
    if (index == word.length()) return true;
    if (i < 0 || j < 0
        || i >= board.length|| j >= board[0].length
        || board[i][j] != word.charAt(index) || used[i][j])
        return false;
    used[i][j] = true;
    boolean result = backtrack(board, used, i - 1, j, index + 1, word)
                    || backtrack(board, used, i + 1, j, index + 1, word)
                    || backtrack(board, used, i, j - 1, index + 1, word)
                    || backtrack(board, used, i, j + 1, index + 1, word);
    // for backtracking
    used[i][j] = false;
    return result;
}
```

Version 2
Time O(m * n * 4 ^ k), m, n = dims of board, k = word.length()
max depth is 4 ^ k, recursively traversing the 4 adjacent cells at each step.
Space O(4 ^ k)
```java
public boolean exist(char[][] board, String word) {
    if (word == null || word.length() == 0)
        return true;
    if (board == null || board.length == 0 || board[0].length == 0)
        return false;
    for (int i = 0; i < board.length; i++) {
        for (int j = 0; j < board[0].length; j++) {
            if (backtrack(board, i, j, 0, word))
                return true;
        }
    }
    return false;
}

private boolean backtrack(char[][] board, int i, int j, int index, String word) {
    if (index == word.length()) return true;
    if (i < 0 || j < 0
        || i >= board.length|| j >= board[0].length
        || board[i][j] != word.charAt(index))
        return false;
    // set the checked position
    board[i][j] ^= 256;
    boolean result = backtrack(board, i - 1, j, index + 1, word)
                    || backtrack(board, i + 1, j, index + 1, word)
                    || backtrack(board, i, j - 1, index + 1, word)
                    || backtrack(board, i, j + 1, index + 1, word);
    // for backtracking
    board[i][j] ^= 256;
    return result;
}
```


## Target Sum

[Problem URL](https://leetcode.com/problems/target-sum)

Description:

> You are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.
> 
> Find out how many ways to assign symbols to make sum of integers equal to target S.
> 
> Example 1:
> Input: nums is [1, 1, 1, 1, 1], S is 3. 
> Output: 5
> Explanation: 
> 
> -1+1+1+1+1 = 3
> +1-1+1+1+1 = 3
> +1+1-1+1+1 = 3
> +1+1+1-1+1 = 3
> +1+1+1+1-1 = 3
> 
> There are 5 ways to assign symbols to make the sum of nums be target 3.
> Note:
> The length of the given array is positive and will not exceed 20.
> The sum of elements in the given array will not exceed 1000.
> Your output answer is guaranteed to be fitted in a 32-bit integer.

Solution:
```java
// Time O(s * n), n = nums.length, s = range of sum
// Space O(s)
public int findTargetSumWays(int[] nums, int S) {
    if (nums == null || nums.length == 0)
        return 0;
    int sum = 0;
    for (int num : nums)
        sum += num;
    // S(P) represents sum of positive values
    // S(N) represents abs(sum) of negative values
    // S(P) - S(N) = S, S(P) - S(N) + S(P) = S + S(P)
    // so 2 * S(P) = S + sum(nums)
    return sum < S || (sum + S) % 2 != 0 ? 0 : subsetSum(nums, (sum + S) / 2);
}

private int subsetSum(int[] nums, int sum) {
    // dp[i] = #ways to get sum i - 1
    int[] dp = new int[sum + 1];
    dp[0] = 1;
    for (int num : nums)
        for (int i = sum; i >= num; i--)
            dp[i] += dp[i - num];
    return dp[sum];
}
```


## Design Search Autocomplete System

[Problem URL](https://leetcode.com/problems/design-search-autocomplete-system)

Description:

> Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#'). For each character they type except '#', you need to return the top 3 historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:
> 
>     The hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.
>     The returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).
>     If less than 3 hot sentences exist, then just return as many as you can.
>     When the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.
> 
> Your job is to implement the following functions:
> 
> The constructor function:
> 
> AutocompleteSystem(String[] sentences, int[] times): This is the constructor. The input is historical data. Sentences is a string array consists of previously typed sentences. Times is the corresponding times a sentence has been typed. Your system should record these historical data.
> 
> Now, the user wants to input a new sentence. The following function will provide the next character the user types:
> 
> List<String> input(char c): The input c is the next character typed by the user. The character will only be lower-case letters ('a' to 'z'), blank space (' ') or a special character ('#'). Also, the previously typed sentence should be recorded in your system. The output will be the top 3 historical hot sentences that have prefix the same as the part of sentence already typed.
> 
> Example:
> Operation: AutocompleteSystem(["i love you", "island","ironman", "i love leetcode"], [5,3,2,2])
> The system have already tracked down the following sentences and their corresponding times:
> "i love you" : 5 times
> "island" : 3 times
> "ironman" : 2 times
> "i love leetcode" : 2 times
> Now, the user begins another search:
> 
> Operation: input('i')
> Output: ["i love you", "island","i love leetcode"]
> Explanation:
> There are four sentences that have prefix "i". Among them, "ironman" and "i love leetcode" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, "i love leetcode" should be in front of "ironman". Also we only need to output top 3 hot sentences, so "ironman" will be ignored.
> 
> Operation: input(' ')
> Output: ["i love you","i love leetcode"]
> Explanation:
> There are only two sentences that have prefix "i ".
> 
> Operation: input('a')
> Output: []
> Explanation:
> There are no sentences that have prefix "i a".
> 
> Operation: input('#')
> Output: []
> Explanation:
> The user finished the input, the sentence "i a" should be saved as a historical sentence in system. And the following input will be counted as a new search.
> 
> Note:
> 
>     The input sentence will always start with a letter and end with '#', and only one blank space will exist between two words.
>     The number of complete sentences that to be searched won't exceed 100. The length of each sentence including those in the historical data won't exceed 100.
>     Please use double-quote instead of single-quote when you write test cases even for a character input.
>     Please remember to RESET your class variables declared in class AutocompleteSystem, as static/class variables are persisted across multiple test cases. Please see here for more details.


Solution:
Time:
AutocompleteSystem(), O(n * k) (n is sentences.length, k is average length of each sentence)
input(), O(p + mlogm) (p is the length of the sentences filled by now, m is the #options for hot sentences)

Space:
AutocompleteSystem(), O(n * k)
input(), O(p + m)
```java
class AutocompleteSystem {
    class TrieNode {
        Map<Character, TrieNode> children;
        Map<String, Integer> count;
        
        public TrieNode() {
            children = new HashMap<>();
            count = new HashMap<>();
        }
    }
    
    class Pair {
        String str;
        int cnt;
        
        public Pair(String s, int c) {
            str = s;
            cnt = c;
        } 
    }
    
    TrieNode root;
    String prefix;
    
    public AutocompleteSystem(String[] sentences, int[] times) {
        root = new TrieNode();
        prefix = "";
        for (int i = 0; i < sentences.length; i++)
            add(sentences[i], times[i]);
    }
    
    private void add(String str, int time) {
        // add the current sentence to trie
        TrieNode curr = root;
        for (char c : str.toCharArray()) {
            TrieNode next = curr.children.get(c);
            if (next == null) {
                next = new TrieNode();
                curr.children.put(c, next);
            }
            curr = next;
            curr.count.put(str, curr.count.getOrDefault(str, 0) + time);
        }
    }
    
    public List<String> input(char c) {
        if (c == '#') {
            // finish search, add prefix input into historical searching
            add(prefix, 1);
            prefix = "";
            return new ArrayList<>();
        }
        
        prefix += c;
        TrieNode curr = root;
        
        // find the children
        for (char letter : prefix.toCharArray()) {
            TrieNode next = curr.children.get(letter);
            // not in history, return empty list
            if (next == null)
                return new ArrayList<>();
            curr = next;
        }
        
        PriorityQueue<Pair> pq = new PriorityQueue<>((p1, p2) -> (p1.cnt == p2.cnt) ? p1.str.compareTo(p2.str) : p2.cnt - p1.cnt);
        for (String str : curr.count.keySet())
            pq.offer(new Pair(str, curr.count.get(str)));
        
        List<String> res = new ArrayList<>();
        for (int i = 0; i < 3 && !pq.isEmpty(); i++)
            res.add(pq.poll().str);
        return res;
    }
}

/**
 * Your AutocompleteSystem object will be instantiated and called as such:
 * AutocompleteSystem obj = new AutocompleteSystem(sentences, times);
 * List<String> param_1 = obj.input(c);
 */
```

## Lowest Common Ancestor Of A Binary Tree

[Problem URL](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree)

Description:

> Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
> 
> According to the definition of LCA on Wikipedia: â€œThe lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).â€
> 
>         _______3______
>        /              \
>     ___5__          ___1__
>    /      \        /      \
>    6      _2       0       8
>          /  \
>          7   4
> For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.


Solution1:
Recursive
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
// Time O(n)
// Space O(n)
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        // root == null means two nodes not in same subtree anymore
        // root == p or root == q means one of the nodes is in the subtree
        return root;
    }
    // check left subtree
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    // check right subtree
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    // if left subtree doesn't contain either node, return result from right subtree
    // if at least one of the nodes in left subtree, check if the other in right subtree
    // if not, return left node
    // if yes, it means two nodes in different subtree, return root
    return left == null ? right : right == null ? left : root;
}
```

Solution2:
Iterative
```java
// Time O(n)
// Space O(n)
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        // root == null means two nodes not in same subtree anymore
        // root == p or root == q means one of the nodes is in the subtree
        return root;
    }
    Map<TreeNode, TreeNode> parent = new HashMap<>();
    Deque<TreeNode> stack = new ArrayDeque<>();
    parent.put(root, null);
    stack.push(root);
    while (!parent.containsKey(p) || !parent.containsKey(q)) {
        TreeNode node = stack.pop();
        if (node.left != null) {
            parent.put(node.left, node);
            stack.push(node.left);
        }
        if (node.right != null) {
            parent.put(node.right, node);
            stack.push(node.right);
        }
    }
    Set<TreeNode> ancestors = new HashSet<>();
    while (p != null) {
        ancestors.add(p);
        p = parent.get(p);
    }
    while (!ancestors.contains(q))
        q = parent.get(q);
    return q;
}
```


## Continuous Subarray Sum

[Problem URL](https://leetcode.com/problems/continuous-subarray-sum)

Description:

> Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to the multiple of k, that is, sums up to n*k where n is also an integer.
> 
> Example 1:
> Input: [23, 2, 4, 6, 7],  k=6
> Output: True
> Explanation: Because [2, 4] is a continuous subarray of size 2 and sums up to 6.
> Example 2:
> Input: [23, 2, 6, 4, 7],  k=6
> Output: True
> Explanation: Because [23, 2, 6, 4, 7] is an continuous subarray of size 5 and sums up to 42.
> Note:
> The length of the array won't exceed 10,000.
> You may assume the sum of all the numbers is in the range of a signed 32-bit integer.

Solution:
```java
// Time O(n)
// Space O(min(n, k))
public boolean checkSubarraySum(int[] nums, int k) {
    // key sum
    // value index
    Map<Integer, Integer> map = new HashMap<>();
    map.put(0, -1);
    int runningSum = 0;
    for (int i = 0; i < nums.length; i++) {
        runningSum += nums[i];
        if (k != 0)
            runningSum %= k;
        Integer prevIdx = map.get(runningSum);
        if (prevIdx != null) {
            if (i - prevIdx > 1)
                return true;
        } else {
            map.put(runningSum, i);
        }
    }
    return false;
}
```


## Walls and Gates

[Problem URL](https://leetcode.com/problems/walls-and-gates/)

> You are given a m x n 2D grid initialized with these three possible values.
> 
> -1 - A wall or an obstacle.
> 0 - A gate.
> INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.
> 
> Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.
> 
> For example, given the 2D grid:
> 
> INF  -1  0  INF
> INF INF INF  -1
> INF  -1 INF  -1
>   0  -1 INF INF
> 
> After running your function, the 2D grid should be:
> 
>   3  -1   0   1
>   2   2   1  -1
>   1  -1   2  -1
>   0  -1   3   4


Solution:
Classic BFS, time O(m * n), space O(m * n)
```java
public void wallsAndGates(int[][] rooms) {
    if (rooms == null || rooms.length == 0)
        return;
    int m = rooms.length, n = rooms[0].length;
    int empty = Integer.MAX_VALUE;
    int gate = 0;
    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    Queue<int[]> q = new LinkedList<>();
    // enqueue all the gates
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (rooms[i][j] == gate)
                q.offer(new int[] {i, j});
    // mark distances
    // bfs will first find the nearest, then the 2nd-nearest
    while (!q.isEmpty()) {
        int[] pos = q.poll();
        int i = pos[0], j = pos[1];
        for (int[] dir : dirs) {
            int x = i + dir[0], y = j + dir[1];
            if (x >= 0 && x < m && y >= 0 && y < n && rooms[x][y] == empty) {
                rooms[x][y] = rooms[i][j] + 1;
                q.offer(new int[] {x, y});
            }
        }
    }
}
```


## Group Anagrams

[Problem URL](https://leetcode.com/problems/group-anagrams)

Description:

> Given an array of strings, group anagrams together.
> 
> For example, given: ["eat", "tea", "tan", "ate", "nat", "bat"],
> Return:
> 
> [
>   ["ate", "eat","tea"],
>   ["nat","tan"],
>   ["bat"]
> ]
> 
> Note: All inputs will be in lower-case.

Solution1:
Time O(n * mlogm), n is strs.length, m is max length of the string
Space O(n * m), total data store in the hashmap
```java
public List<List<String>> groupAnagrams(String[] strs) {
    List<List<String>> res = new ArrayList<>();
    if (strs == null || strs.length == 0)
        return res;
    Map<String, List<String>> map = new HashMap<>();
    for (String str : strs) {
        char[] letters = str.toCharArray();
        Arrays.sort(letters);
        String key = new String(letters);
        map.putIfAbsent(key, new ArrayList<>());
        map.get(key).add(str);
    }
    for (List<String> list : map.values())
        res.add(list);
    return res;
}
```


Solution2:
Use count as hash key
Tme O(n * m), n = strs.length, m = max length of the str
Space O(n * m)
```java
public List<List<String>> groupAnagrams(String[] strs) {
    if (strs == null || strs.length == 0)
        return new ArrayList<>();
    Map<String, List<String>> map = new HashMap<>();
    int[] count = new int[26];
    for (String str : strs) {
        Arrays.fill(count, 0);
        // store the frequencies of letters
        for (char c : str.toCharArray())
            count[c - 'a']++;
        StringBuilder sb = new StringBuilder();
        for (int cnt : count)
            // ":" as delimiter for counts
            sb.append(":").append(cnt);
        String key = sb.toString();
        map.putIfAbsent(key, new ArrayList<>());
        map.get(key).add(str);
    }
    return new ArrayList<>(map.values());
}
```


## Count And Say

[Problem URL](https://leetcode.com/problems/count-and-say)

Description:

> The count-and-say sequence is the sequence of integers with the first five terms as following:
> 
> 1.     1
> 2.     11
> 3.     21
> 4.     1211
> 5.     111221
> 1 is read off as "one 1" or 11.
> 11 is read off as "two 1s" or 21.
> 21 is read off as "one 2, then one 1" or 1211.
> Given an integer n, generate the nth term of the count-and-say sequence.
> 
> Note: Each term of the sequence of integers will be represented as a string.
> 
> Example 1:
> 
> Input: 1
> Output: "1"
> Example 2:
> 
> Input: 4
> Output: "1211"


Solution1:
```java
// Time O(n * m), m is average length of each string representation
// Space O(n * m)
public String countAndSay(int n) {
    String s = "1";
    while (n-- > 1) { /* invariant: s is nth */
        StringBuilder next = new StringBuilder(); /* invariant: contain cnt-say before cur */
        for (int i = 0, cnt = 1; i < s.length(); i++, cnt++) {
            if (i == s.length() - 1 || s.charAt(i) != s.charAt(i + 1)) {
                next.append(cnt).append(s.charAt(i));
                cnt = 0;
            }
        }
        s = next.toString();
    }
    return s;
}
```

Solution2:
```java
// Time O(n * m), m is average length of each string representation
// Space O(n * m)
public String countAndSay(int n) {
    String res = "1";
    // n - 1 rounds left
    for (int i = 1; i < n; i++)
        res = build(res);
    return res;
}

private String build(String curr) {
    StringBuilder sb = new StringBuilder();
    int i = 0;
    while (i < curr.length()) {
        char digit = curr.charAt(i);
        int count = 0;
        // count the occurrence of the same digit
        while (i < curr.length() && curr.charAt(i) == digit) {
            i++;
            count++;
        }
        sb.append(count);
        sb.append(digit);
    }
    return sb.toString();
}
```


## Maximum Size Subarray Sum Equals K

[Problem URL](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k)

Description:

> Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead.
> 
> Note:
> The sum of the entire nums array is guaranteed to fit within the 32-bit signed integer range.
> 
> Example 1:
> 
> Given nums = [1, -1, 5, -2, 3], k = 3,
> return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longGest)
> 
> Example 2:
> 
> Given nums = [-2, -1, 2, 1], k = 1,
> return 2. (because the subarray [-1, 2] sums to 1 and is the longest)
> 
> Follow Up:
> Can you do it in O(n) time?

Solution:
Time O(n), space O(n)
```java
public int maxSubArrayLen(int[] nums, int k) {
    // key, current sum up to nums[i]
    // value, index i
    Map<Integer, Integer> sumToIdx = new HashMap<>();
    int sum = 0, res = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
        if (sum == k)
            res = i + 1;
        // previously, at some index j, the summation = sum - k
        // so sum - (sum - k) = k,
        // length = i - j + 1 (total #elements) - 1 (sum at j is not included)
        else if (sumToIdx.containsKey(sum - k))
            res = Math.max(res, i - sumToIdx.get(sum - k));
        if (!sumToIdx.containsKey(sum))
            sumToIdx.put(sum, i);
    }
    return res;
}
```

## Move Zeroes

[Problem URL](https://leetcode.com/problems/move-zeroes)

Description:

> Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.
> 
> For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].
> 
> Note:
> You must do this in-place without making a copy of the array.
> Minimize the total number of operations.

Solution:
```java
// Time O(n)
// Space O(1)
public void moveZeroes(int[] nums) {
    if (nums == null || nums.length == 0)
        return;        
    for (int lastNonZero = 0, cur = 0; cur < nums.length; cur++) {
        if (nums[cur] != 0) {
            int temp = nums[cur];
            nums[cur] = nums[lastNonZero];
            nums[lastNonZero++] = temp;
        }
    }
}
```


## Remove Invalid Parentheses

[Problem URL](https://leetcode.com/problems/remove-invalid-parentheses)

Description:

> Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.
> 
> Note: The input string may contain letters other than the parentheses ( and ).
> 
> Examples:
> "()())()" -> ["()()()", "(())()"]
> "(a)())()" -> ["(a)()()", "(a())()"]
> ")(" -> [""]


Solution1:
DFS
Solution:
```java
// Time: O(2 ^ n), n = s.length(), each time we need to make a choice of adding the parentheses or not
// Space: O(n), max depth is n
public List<String> removeInvalidParentheses(String s) {
    // removalable open and close
    int rmOpen = 0, rmClose = 0;
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            rmOpen++;
        } else if (s.charAt(i) == ')') {
            if (rmOpen != 0) {
                rmOpen--;
            } else {
                rmClose++;
            }
        }
    }
    Set<String> res = new HashSet<>();
    dfs(s, 0, res, new StringBuilder(), rmOpen, rmClose, 0);
    return new ArrayList<String>(res);
}

// avoiding invalid strs (on the fly) by checking num of open parens.
public void dfs(String s, int i, Set<String> res, StringBuilder sb, int rmOpen, int rmClose, int open) {
    if (rmOpen < 0 || rmClose < 0 || open < 0) {
        return;
    }
    if (i == s.length()) {
        if (rmOpen == 0 && rmClose == 0 && open == 0) {
            res.add(sb.toString());
        }        
        return;
    }

    char c = s.charAt(i); 
    int len = sb.length();
    // If itâ€™s '(', either use it, or remove it.
    // If itâ€™s '(', either use it, or remove it.
    // Otherwise just append it.
    if (c == '(') {
        dfs(s, i + 1, res, sb, rmOpen - 1, rmClose, open);          // not use (
        dfs(s, i + 1, res, sb.append(c), rmOpen, rmClose, open + 1);       // use (

    } else if (c == ')') {
        dfs(s, i + 1, res, sb, rmOpen, rmClose - 1, open);              // not use  )
        dfs(s, i + 1, res, sb.append(c), rmOpen, rmClose, open - 1);        // use )

    } else {
        dfs(s, i + 1, res, sb.append(c), rmOpen, rmClose, open);    
    }
    // restore state, set StringBuilder to the last decision point
    sb.setLength(len);        
}
```


Solution2:
BFS
```java
// Time:
// On the first level, thereâ€™s only one string which is the input string s,
// letâ€™s say the length of it is n, to check whether itâ€™s valid, we need O(n) time.
// On the second level, we remove one ( or ) from the first level,
// so there are C(n, n-1) new strings, each of them has n-1 characters,
// and for each string, we need to check whether itâ€™s valid or not,
// thus the total time complexity on this level is (n-1) x C(n, n-1).
// Come to the third level, total time complexity is (n-2) x C(n, n-2), so on and so forthâ€¦
// Finally we have this formula:
// T(n) = n x C(n, n) + (n-1) x C(n, n-1) + â€¦ + 1 x C(n, 1) = n x 2^(n-1).
//
// Space: O(n)
public List<String> removeInvalidParentheses(String s) {
    List<String> res = new ArrayList<>();
    if (s == null) {
        return res;
    }
    Set<String> visited = new HashSet<>();
    Queue<String> queue = new LinkedList<>();
    visited.add(s);
    queue.offer(s);
    boolean found = false;
    while (!queue.isEmpty()) {
        String curr = queue.poll();
        if (isValid(curr)) {
            res.add(curr);
            found = true;
        }
        if (found) {
            continue;
        }
        for (int i = 0; i < curr.length(); i++) {
            char c = curr.charAt(i);
            if (c != '(' && c != ')') {
                continue;
            }
            String next = curr.substring(0, i) + curr.substring(i + 1);
            if (!visited.contains(next)) {
                visited.add(next);
                queue.offer(next);
            }
        }
    }
    return res;
}

private boolean isValid(String str) {
    int count = 0;
    for (int i = 0; i < str.length(); i++) {
        char c = str.charAt(i);
        if (c == '(') {
            count++;
        }
        if (c == ')') {
            count--;
        }
        if (count < 0) {
            return false;
        }
    }
    return count == 0;
}
```


## Add Binary

[Problem URL](https://leetcode.com/problems/add-binary)

Description:

> Given two binary strings, return their sum (also a binary string).
> 
> For example,
> a = "11"
> b = "1"
> Return "100".

Solution:
```java
// Ttime O(max(m, n)) (m, n = length of a, b)
// Space O(1)
public String addBinary(String a, String b) {
    StringBuilder sb = new StringBuilder();
    int i = a.length() - 1, j = b.length() - 1;
    int carry = 0, sum = 0;
    while (i >= 0 || j >= 0) {
        sum = carry;
        if (i >= 0)
            sum += a.charAt(i--) - '0';
        if (j >= 0)
            sum += b.charAt(j--) - '0';
        sb.append(sum % 2);
        carry = sum / 2;
    }
    if (carry != 0)
        sb.append(carry);
    return sb.reverse().toString();
}
```


## Sparse Matrix Multiplication

[Problem URL](https://leetcode.com/problems/sparse-matrix-multiplication)

Description:

> Given two sparse matrices A and B, return the result of AB.
> 
> You may assume that A's column number is equal to B's row number.
> 
> Example:
> 
> A = [
>   [ 1, 0, 0],
>   [-1, 0, 3]
> ]
> 
> B = [
>   [ 7, 0, 0 ],
>   [ 0, 0, 0 ],
>   [ 0, 0, 1 ]
> ]
> 
> 
>      |  1 0 0 |   | 7 0 0 |   |  7 0 0 |
> AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 |
>                   | 0 0 1 |


Solution1:
Use a map to store index and values of nonzeros in A
Time O(a * l) (a = #nonzero in A, l = B[0].length)
Space O(a + m * l) (m = A.length)
```java
public int[][] multiply(int[][] A, int[][] B) {
    int m = A.length, n = A[0].length, l = B[0].length;
    int[][] res = new int[m][l];
    Map<Integer, Map<Integer, Integer>> nonZero = new HashMap<>();
    for (int i = 0; i < m; i++) {
        nonZero.put(i, new HashMap<>());
        for (int j = 0; j < n; j++)
            if (A[i][j] != 0)
                nonZero.get(i).put(j, A[i][j]);
    }
    for (int i = 0; i < m; i++)
        for (int k : nonZero.get(i).keySet())
            for (int j = 0; j < l; j++)
                if (B[k][j] != 0)
                    res[i][j] += nonZero.get(i).get(k) * B[k][j];
    return res;
}
```


Solution2:
```java
// Time O(m * n * nB), basically O(a * nB), a = #non-zeros in A
// Space O(1), without counting result, otherwise O(m * nB)
public int[][] multiply(int[][] A, int[][] B) {
    int m = A.length, n = A[0].length, nB = B[0].length;
    int[][] res = new int[m][nB];
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (A[i][j] != 0)
                for (int k = 0; k < nB; k++)
                    if (B[j][k] != 0)
                        res[i][k] += A[i][j] * B[j][k];
    return res;
}
```


## Binary Tree Vertical Order Traversal

[Problem URL](https://leetcode.com/problems/binary-tree-vertical-order-traversal)

Description:

> Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).
> 
> If two nodes are in the same row and column, the order should be from left to right.
> 
> Examples:
> 
>     Given binary tree [3,9,20,null,null,15,7],
> 
>        3
>       /\
>      /  \
>      9  20
>         /\
>        /  \
>       15   7
> 
>     return its vertical order traversal as:
> 
>     [
>       [9],
>       [3,15],
>       [20],
>       [7]
>     ]
> 
>     Given binary tree [3,9,8,4,0,1,7],
> 
>          3
>         /\
>        /  \
>        9   8
>       /\  /\
>      /  \/  \
>      4  01   7
> 
>     return its vertical order traversal as:
> 
>     [
>       [4],
>       [9],
>       [3,0,1],
>       [8],
>       [7]
>     ]
> 
>     Given binary tree [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5),
> 
>          3
>         /\
>        /  \
>        9   8
>       /\  /\
>      /  \/  \
>      4  01   7
>         /\
>        /  \
>        5   2
> 
>     return its vertical order traversal as:
> 
>     [
>       [4],
>       [9,5],
>       [3,0,1],
>       [8,2],
>       [7]
>     ]

 
Solution:
BFS-based, enqueue node and column index at the same time
Time O(n), n is #nodes in the tree, traverse entire tree
Space O(m), m = max possible columns (fibonacci seq)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public List<List<Integer>> verticalOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null)
        return res;
    // key is column index
    // value is list of nodes 
    Map<Integer, List<Integer>> map = new HashMap<>();
    Queue<TreeNode> nodes = new LinkedList<>();
    Queue<Integer> cols = new LinkedList<>();
    int minCol = 0, maxCol = 0;
    // enqueue node and col index at the same time
    nodes.offer(root);
    cols.offer(0);
    while (!nodes.isEmpty()) {
        TreeNode currNode = nodes.poll();
        int currCol = cols.poll();
        if (!map.containsKey(currCol))
            map.put(currCol, new ArrayList<>());
        map.get(currCol).add(currNode.val);
        // enqueue left and curr col - 1
        if (currNode.left != null) {
            nodes.offer(currNode.left);
            cols.offer(currCol - 1);
            minCol = Math.min(minCol, currCol - 1);
        }
        // enqueue right and curr col + 1
        if (currNode.right != null) {
            nodes.offer(currNode.right);
            cols.offer(currCol + 1);
            maxCol = Math.max(maxCol, currCol + 1);
        }
    }
    for (int i = minCol; i <= maxCol; i++)
        res.add(map.get(i));
    return res;
}
```


## Integer To English Words

[Problem URL](https://leetcode.com/problems/integer-to-english-words)

Description:

> Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2^31 - 1.
> 
> For example,
> 123 -> "One Hundred Twenty Three"
> 12345 -> "Twelve Thousand Three Hundred Forty Five"
> 1234567 -> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"

Solution:
```java
// Time O(1), #call of trans is constant
// loop will be called at most 4 times. It could trigger at most 3 recursive calls in each recursion.
// It will run 4 * 3 which is O(12) = O(1)
// Space O(1)
final String[] LESS_THAN_20 = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
final String[] TENS = {"", "Ten", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
final String[] THOUSANDS = {"Billion", "Million", "Thousand", ""};
final int[] radix = {1000000000, 1000000, 1000, 1};

public String numberToWords(int num) {
    if (num == 0)
        return "Zero";
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < THOUSANDS.length; i++) {
        int count = num / radix[i];
        if (count == 0)
            continue;
        sb.append(trans(count)).append(THOUSANDS[i]).append(" ");
        num %= radix[i];
    }
    return sb.toString().trim();
}

private String trans(int num) {
    if (num == 0)
        return "";
    if (num < 20)
        return LESS_THAN_20[num] + " ";
    if (num < 100)
        return TENS[num / 10] + " " + trans(num % 10);
    return LESS_THAN_20[num / 100] + " Hundred " + trans(num % 100);
}
```


## Letter Combinations of a Phone Number

[Problem URL](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

Description:

> Given a digit string, return all possible letter combinations that the number could represent.
> 
> A mapping of digit to letters (just like on the telephone buttons) is given below.
> 
> Input:Digit string "23"
> Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
> 
> Note:
> Although the above answer is in lexicographical order, your answer could be in any order you want. 


Solution1:
Backtracking
Time O(4 ^ n)
Space O(n), max depth is n
```java
public List<String> letterCombinations(String digits) {
    LinkedList<String> res = new LinkedList<>();
    if (digits == null || digits.length() == 0)
        return res;
    String[] mappings = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    backtrack(res, mappings, digits, new StringBuilder(""), 0);
    return res;
}

private void backtrack(LinkedList<String> res, String[] mappings, String digits, StringBuilder curr, int index) {
    if (index ==  digits.length()) {
        res.add(curr.toString());
        return;
    }
    String letters = mappings[digits.charAt(index) - '0'];
    for (char c : letters.toCharArray()) {
        curr.append(c);
        backtrack(res, mappings, digits, curr, index + 1);
        curr.deleteCharAt(curr.length() - 1);
    }
}
```


Solution2:
BFS
```java
// Time O(4 ^ n), n = digits.length(), at each position
// there are up to 4 possibilities
// Space O(1), without counting result, otherwise O(4 ^ n)
public List<String> letterCombinations(String digits) {
    LinkedList<String> res = new LinkedList<>();
    if (digits == null || digits.length() == 0)
        return res;
    res.add("");
    String[] mappings = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    for (int i = 0; i < digits.length(); i++) {
        int digit = digits.charAt(i) - '0';
        while (res.peek().length() == i) {
            String curr = res.remove();
            for (char c : mappings[digit].toCharArray())
                res.add(curr + c);
        }
    }
    return res;
}
```


## Decode Ways
[Problem URL](https://leetcode.com/problems/decode-ways/)

Description:

> A message containing letters from A-Z is being encoded to numbers using the following mapping:

> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26

> Given an encoded message containing digits, determine the total number of ways to decode it.

> For example,
> Given encoded message "12", it could be decoded as "AB" (1 2) or "L" (12).

> The number of ways decoding "12" is 2.


One way of thinking is start from the 1st digit and all the way through the end. The number of decode ways depends on whether the current digit itself can be decoded and if the current digit with the previous digit together can be decoded.

Assume f(i) represents the number of ways to decode the i-th digit, then it will be 4 possibilities:

- the current digit itself cannot be decoded and with its previous digit cannot be decoded either, i.e. 00, then f(i) = 0
- the current digit itself can be decode, but cannot be decoded if with the previous digit, i.e. 01 - 09, 27 - 99, then f(i) = f(i - 1)
- the current digit itself cannot be decode, but with its previous digit can be decoded, i.e. 10 and 20, then f(i) = f(i - 2)
- both ways work, i.e. 11 - 26, then f(i) = f(i - 1) + f(i - 2)

Since only f(i - 1) and f(i - 2) are needed, two variables are enough to store them, no need to use an array, time O(n), space O(1):

Solution1:
```java
// Time O(n)
// Space O(n)
public int numDecodings(String s) {
    if (s.length() == 0)
        return 0;
    int[] dp = new int[s.length() + 1];
    dp[0] = 1;

    if (s.charAt(0) != '0')
        dp[1] = 1;
    for (int i = 2; i <= s.length(); i++) {
        // single digit
        int first = Integer.valueOf(s.substring(i - 1, i));
        // two digits
        int second = Integer.valueOf(s.substring(i - 2, i));
        if (first >= 1 && first <= 9)
            dp[i] += dp[i - 1];
        if (second >= 10 && second <= 26)
            dp[i] += dp[i - 2];
    }
    return dp[s.length()];
}
```


Solution2:
```java
// Time O(n)
// Space O(1)
public int numDecodings(String s) {
    if (s.length() == 0)
        return 0;
    // lastTwo = dp[i - 2]
    // lastOne = dp[i - 1]
    // res = dp[i]
    int lastTwo = 1, lastOne = 0, res = 0;

    if (s.charAt(0) != '0') {
        lastOne = 1;
        res = 1;
    }
    for (int i = 2; i <= s.length(); i++) {
        res = 0;
        // single digit
        int first = Integer.valueOf(s.substring(i - 1, i));
        // two digits
        int second = Integer.valueOf(s.substring(i - 2, i));
        if (first >= 1 && first <= 9)
            res += lastOne;
        if (second >= 10 && second <= 26)
            res += lastTwo;
        lastTwo = lastOne;
        lastOne = res;
    }
    return res;
}
```


## Decode Ways II 

[Problem URL](https://leetcode.com/problems/decode-ways-ii/)

Description:

> A message containing letters from A-Z is being encoded to numbers using the following mapping way:
> 
> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26
> 
> Beyond that, now the encoded string can also contain the character '*', which can be treated as one of the numbers from 1 to 9.
> 
> Given the encoded message containing digits and the character '*', return the total number of ways to decode it.
> 
> Also, since the answer may be very large, you should return the output mod 109 + 7.
> 
> Example 1:
> 
> Input: "*"
> Output: 9
> Explanation: The encoded message can be decoded to the string: "A", "B", "C", "D", "E", "F", "G", "H", "I".
> 
> Example 2:
> 
> Input: "1*"
> Output: 9 + 9 = 18
> 
> Note:
> 
> The length of the input string will fit in range [1, 105].
> 
> The input string will only contain the character '*' and digits '0' - '9'.


Solution1:
Bottom-up dp, time O(n), space O(n)
```java
// Time O(n)
// Space O(n)
public int numDecodings(String s) {
    int mod = 1000000007;
    int n = s.length();
    // dp[i] = #decode ways of string up to index i - 1
    long[] dp = new long[n + 1];
    dp[0] = 1;
    char curr = s.charAt(0), prev;
    dp[1] = curr == '*' ? 9 : curr == '0' ? 0 : 1;
    for (int i = 1; i < n; i++) {
        curr = s.charAt(i);
        prev = s.charAt(i - 1);
        if (curr == '*') {
            // treat as single digit, 1 - 9
            dp[i + 1] = 9 * dp[i];
            // combine with previous digit
            if (prev == '1')
                // 11 - 19
                // ex: 21*, every possbile way '2' has, there are 9 ways corresponding to it
                dp[i + 1] = (dp[i + 1] + 9 * dp[i - 1]) % mod;
            else if (prev == '2') // 21 - 26
                dp[i + 1] = (dp[i + 1] + 6 * dp[i - 1]) % mod;
            else if (prev == '*') // ** -> 11 - 26
                dp[i + 1] = (dp[i + 1] + 15 * dp[i - 1]) % mod;
        } else {
            dp[i + 1] = curr != '0' ? dp[i] : 0;
            if (prev == '1')
                // only one way
                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;
            else if (prev == '2' && curr <= '6')
                // only one way
                dp[i + 1] = (dp[i + 1] + dp[i - 1]) % mod;
            else if (prev == '*')
                // 2*1, * can be used as 2 or 1, 2 ways
                // 2*9, * can oly be used as 1
                dp[i + 1] = (dp[i + 1] + (curr <= '6' ? 2 : 1) * dp[i - 1]) % mod;
        }
    }
    return (int)dp[n];
}
```

Solution2:
Bottom-up dp, time O(n), space O(1)
```java
public int numDecodings(String s) {
    int mod = 1000000007;
    // dp[i] = #decode ways of string up to index i - 1
    char currChar = s.charAt(0), prevChar;
    long prevCnt = 1, currCnt = currChar == '*' ? 9 : currChar == '0' ? 0 : 1;
    for (int i = 1; i < s.length(); i++) {
        currChar = s.charAt(i);
        prevChar = s.charAt(i - 1);
        long temp = currCnt;
        if (currChar == '*') {
            currCnt = 9 * currCnt;
            if (prevChar == '1')
                currCnt = (currCnt + 9 * prevCnt) % mod;
            else if (prevChar == '2')
                currCnt = (currCnt + 6 * prevCnt) % mod;
            else if (prevChar == '*')
                currCnt = (currCnt + 15 * prevCnt) % mod;
        } else {
            currCnt = currChar != '0' ? currCnt : 0;
            if (prevChar == '1')
                currCnt = (currCnt + prevCnt) % mod;
            else if (prevChar == '2' && currChar <= '6')
                currCnt = (currCnt + prevCnt) % mod;
            else if (prevChar == '*')
                currCnt = (currCnt + (currChar <= '6' ? 2 : 1) * prevCnt) % mod;
        }
        prevCnt = temp;
    }
    return (int)currCnt;
}
```

## Meeting Rooms

[Problem URL](https://leetcode.com/problems/meeting-rooms)

Description:

> Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.
> 
> For example,
> Given [[0, 30],[5, 10],[15, 20]],
> return false.

Solution:
Sort the intervals by start
Time O(nlogn), space O(1)
```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public boolean canAttendMeetings(Interval[] intervals) {
    Arrays.sort(intervals, (i1, i2) -> (i1.start - i2.start));
    for (int i = 0; i < intervals.length - 1; i++)
        if (intervals[i].end > intervals[i + 1].start)
            return false;
    return true;
}
```


## Meeting Rooms II

[Problem URL](https://leetcode.com/problems/meeting-rooms-ii)

Description:

> Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.
> 
> For example,
> Given [[0, 30],[5, 10],[15, 20]],
> return 2. 


Solution1:
Time O(nlgn), space O(n)
```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public int minMeetingRooms(Interval[] intervals) {
    if (intervals == null || intervals.length == 0)
        return 0;
    Arrays.sort(intervals, (i1, i2) -> (i1.start - i2.start));
    PriorityQueue<Interval> pq = new PriorityQueue<>((i1, i2) -> (i1.end - i2.end));
    int res = 0;
    for (int i = 0; i < intervals.length; i++) {
        // only keep meetings that need a new room
        while (!pq.isEmpty() && intervals[i].start >= pq.peek().end)
            pq.poll();
        pq.offer(intervals[i]);
        res = Math.max(res, pq.size());
    }
    return res;
}
```


Solution2:
Time O(nlgn), space O(n)
```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public int minMeetingRooms(Interval[] intervals) {
    if (intervals == null || intervals.length == 0)
        return 0;
    int n = intervals.length;
    int[] starts = new int[n];
    int[] ends = new int[n];
    for (int i = 0; i < n; i++) {
        starts[i] = intervals[i].start;
        ends[i] = intervals[i].end;
    }
    Arrays.sort(starts);
    Arrays.sort(ends);
    int res = 0, endIdx = 0;
    for (int i = 0; i < n; i++)
        if (starts[i] < ends[endIdx])
            res++;
        else
            endIdx++;
    return res;
}
```


## Regular Expression Matching

[Problem URL](https://leetcode.com/problems/regular-expression-matching/)

Description:

> Implement regular expression matching with support for '.' and '*'.
> 
> '.' Matches any single character.
> '*' Matches zero or more of the preceding element.
> 
> The matching should cover the entire input string (not partial).
> 
> The function prototype should be:
> bool isMatch(const char *s, const char *p)
> 
> Some examples:
> isMatch("aa","a") â†’ false
> isMatch("aa","aa") â†’ true
> isMatch("aaa","aa") â†’ false
> isMatch("aa", "a*") â†’ true
> isMatch("aa", ".*") â†’ true
> isMatch("ab", ".*") â†’ true
> isMatch("aab", "c*a*b") â†’ true

Solution1:
Bottom-up dp, time O(mn), space O(mn)
```java
// Time O(m * n), m, n = s.length(), p.length()
// Space O(m * n)
public boolean isMatch(String s, String p) {
    if (s == null || p == null)
        return false;
    int m = s.length(), n = p.length();
    // dp[i][j] = matching result of string s[0: i - 1] with p[0: j - 1]
    boolean[][] dp = new boolean[m + 1][n + 1];
    dp[0][0] = true;
    // initialization for matching "a*" as empty
    for (int j = 2; j <= n; j++)
        dp[0][j] = dp[0][j - 2] && p.charAt(j - 1) == '*';
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) != '*') {
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')
                // if not wildcards
                // and if the current char in pattern matches the current char in string
                    dp[i][j] = dp[i - 1][j - 1];
                // else
                //     dp[i][j] = false;
            } else {
                // if current pattern letter matches current string letter
                // count 'a*' as multiple a or single 'a' or empty
                if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j - 2];
                else
                    // if previous char in pattern doesn't match with current char in string
                    // count 'a*' as matching empty, dp[i][j] = dp[i][j - 2]
                    dp[i][j] = dp[i][j - 2];
            }
        }
    }
    return dp[m][n];
}
```

Solution2:
```java
// Time O(m * n), m, n = s.length(), p.length()
// Space O(n)
public boolean isMatch(String s, String p) {
    if (s == null || p == null)
        return false;
    int m = s.length(), n = p.length();
    boolean[] dp = new boolean[n + 1];
    // dp[0][0] = true;
    dp[0] = true;

    int i, j;
    for (j = 2; j <= n; j++)
        dp[j] = dp[j - 2] && p.charAt(j - 1) == '*';
    // pre=dp[i - 1][j - 1], cur=dp[i - 1][j]
    boolean pre, cur; 

    for (i = 1; i <= m; i++) {
        pre = dp[0];
        // dp[i][0] = false for i >= 1
        dp[0] = false;
        for (j = 1; j <= n; j++) {
            cur = dp[j];
            if (p.charAt(j - 1) != '*') {
                // if not wildcards
                // and if the current char in pattern matches the current char in string
                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')
                    dp[j] = pre;
                else
                    dp[j] = false;
            } else {
                // if current pattern letter matches current string letter
                // count 'a*' as multiple a or single 'a' or empty
                if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')
                    dp[j] = cur || dp[j - 1] || dp[j - 2];
                else
                    // if previous char in pattern doesn't match with current char in string
                    // count 'a*' as matching empty, dp[i][j] = dp[i][j - 2]
                    dp[j] = dp[j - 2];
            }
            pre = cur;
        }
    }
    return dp[n];
}
```


## 3Sum

[Problem URL](https://leetcode.com/problems/3sum)

Description:

> Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
> 
> Note: The solution set must not contain duplicate triplets.
> 
> For example, given array S = [-1, 0, 1, 2, -1, -4],
> 
> A solution set is:
> [
>   [-1, 0, 1],
>   [-1, -1, 2]
> ]


Solution:
```java
// Time O(n ^ 2)
// Space O(1)
public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);
    List<List<Integer>> res = new LinkedList<>(); 
    for (int i = 0; i < nums.length - 2; i++) {
        if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {
            int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];
            while (lo < hi) {
                if (nums[lo] + nums[hi] == sum) {
                    res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));
                    // skip duplicates
                    while (lo < hi && nums[lo] == nums[lo + 1])
                        lo++;
                    // skip duplicates
                    while (lo < hi && nums[hi] == nums[hi - 1])
                        hi--;
                    lo++;
                    hi--;
                } else if (nums[lo] + nums[hi] < sum) {
                    // skip duplicates
                    while (lo < hi && nums[lo] == nums[lo + 1])
                        lo++;
                    lo++;
                }
                else {
                    // skip duplicates
                    while (lo < hi && nums[hi] == nums[hi - 1])
                        hi--;
                    hi--;
                }
           }
        }
    }
    return res;
}
```


## Find The Celebrity

[Problem URL](https://leetcode.com/problems/find-the-celebrity)

Description:

> Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
> 
> Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).
> 
> You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows.
> 
> Note: There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.

Solution:
```java
/* The knows API is defined in the parent class Relation.
      boolean knows(int a, int b); */

// time O(n), space O(1)
public class Solution extends Relation {
    public int findCelebrity(int n) {
        // first identify the candidate
        int candidate = 0;
        for (int i = 1; i < n; i++)
            // if candidate knows i, current candidate cannot be celebrity
            // switch candidate
            if (knows(candidate, i))
                candidate = i;
        // check if candidate is true
        for (int i = 0; i < n; i++)
            // for other people, if candidate knows someone, or someone doesn't know candidate
            // then the candidate is not real
            if (i != candidate && (knows(candidate, i) || !knows(i, candidate)))
                return -1;
        return candidate;
    }
}
```


## Read N Characters Given Read4

[Problem URL](https://leetcode.com/problems/read-n-characters-given-read4)

Description:

> The API: int read4(char *buf) reads 4 characters at a time from a file.
> 
> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.
> 
> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
> 
> Note:
> The read function will only be called once for each test case.

Solution:
```java
/* The read4 API is defined in the parent class Reader4.
      int read4(char[] buf); */

// time O(n), space O(1)
public class Solution extends Reader4 {
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    public int read(char[] buf, int n) {
        int total = 0;
        char[] tmp = new char[4];
        boolean eof = false;
        while (!eof && total < n) {
            int count = read4(tmp);
            eof = count < 4;
            // the total #letters to read may be smaller than the file content
            count = Math.min(count, n - total);
            for (int i = 0; i < count; i++)
                buf[total++] = tmp[i];
        }
        return total;
    }
}
```


## Read N Characters Given Read4 Ii Call Multiple Times

[Problem URL](https://leetcode.com/problems/read-n-characters-given-read4-ii-call-multiple-times)

Description:

> The API: int read4(char *buf) reads 4 characters at a time from a file.
> 
> The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.
> 
> By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
> 
> Note:
> The read function may be called multiple times.


Solution:
```java
/* The read4 API is defined in the parent class Reader4.
      int read4(char[] buf); */

// time O(n), space O(1)
public class Solution extends Reader4 {
    // Keep global variables to store previous read records.
    // stores the previous position copied to buffer
    int buffPtr = 0;
    // stores the previous position read by API
    int buffCnt = 0;
    // stores the last buff read
    char[] buff = new char[4];
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    public int read(char[] buf, int n) {
        // pointer for destination buffer buf
        int ptr = 0;
        while (ptr < n) {
            // read new data
            if (buffPtr == 0)
                buffCnt = read4(buff);
            while (ptr < n && buffPtr < buffCnt)
                buf[ptr++] = buff[buffPtr++];
            // read less than 4 chars, end of file
            if (buffCnt < 4)
                break;
            // all buffer in buff are read
            // set buffPtr to 0 for reading new data
            if (buffPtr == buffCnt)
                buffPtr = 0;
        }
        return ptr;
    }
}
```


## Serialize and Deserialize Binary Tree

[Problem URL](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)

Description:

> Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
> 
> Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.
> 
> For example, you may serialize the following tree
> 
> as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
> Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.


Solution:
Normally, for a given binary tree traversal, it requires inorder traversal and at least another traversal to recover the binary tree. Here, the difference is that in serialization, the binary tree is considered a full binary tree, which means all external nodes (null) would also be serialized. Thus, the binary tree can be reconstructed using only one serialized result.


1. Based on preorder traversal
Solution
Serialize the tree in preorder traversal is easier to deserialize. Must use a delimiter that can easily separate the nodes, e.g. ",". "-" won't work because it may get confused with the negative sign in values. Deserialization is based on the encoded order. Just make sure to get the index of each node correctly. Only increase the index when trying to reach the left and right child of the current node. So when encounter a null node, no need to increase the index.

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {
    // Time O(n)
    // Space O(h), worst case O(n)

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serializeHelper(root, sb);
        return sb.toString();
    }
    
    private void serializeHelper(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append("#").append(",");
            return;
        }
        sb.append(root.val).append(",");
        serializeHelper(root.left, sb);
        serializeHelper(root.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        LinkedList<String> nodes = new LinkedList<>();
        nodes.addAll(Arrays.asList(data.split(",")));
        return deserializeHelper(nodes);
    }
    
    private TreeNode deserializeHelper(LinkedList<String> nodes) {
        String curr = nodes.remove();
        if (curr.equals("#"))
            return null;
        TreeNode root = new TreeNode(Integer.valueOf(curr));
        root.left = deserializeHelper(nodes);
        root.right = deserializeHelper(nodes);
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```


Solution2
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
// Iterative preorder
// Time O(n)
// Space O(h), worst O(n)
public class Codec {
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null)
            return null;
        Stack<TreeNode> stack = new Stack<>();
        StringBuilder sb = new StringBuilder();
        TreeNode curr = root;
        while (curr != null || !stack.isEmpty()) {
            if (curr != null) {
                // visit root
                // then go left
                sb.append(curr.val).append(",");
                stack.push(curr);
                curr = curr.left;
            } else {
                // mark null
                // go back and go right
                sb.append("#").append(",");
                curr = stack.pop().right;
            }
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data == null || data.length() == 0)
            return null;
        String[] nodes = data.split(",");
        int n = nodes.length;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode root = new TreeNode(Integer.valueOf(nodes[0]));
        TreeNode curr = root;
        stack.push(curr);
        int i = 1;
        while (i < n) {
            // always first go as left as possible
            while (i < n && !nodes[i].equals("#")) {
                curr.left = new TreeNode(Integer.valueOf(nodes[i++]));
                curr = curr.left;
                stack.push(curr);
            }
            // reaches null, go back until a valid node
            while (i < n && nodes[i].equals("#")) {
                curr = stack.pop();
                i++;
            }
            // go to right
            if (i < n) {
                curr.right = new TreeNode(Integer.valueOf(nodes[i++]));
                curr = curr.right;
                stack.push(curr);
            }
        }
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```


Solution3
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
// Iterative BFS
// Time O(n)
// Space O(n), worst case root has all nodes as children
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null)
            return "";
        Queue<TreeNode> queue = new LinkedList<>();
        StringBuilder sb = new StringBuilder();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode curr = queue.poll();
            if (curr == null) {
                sb.append("#").append(",");
                continue;
            }
            sb.append(curr.val).append(",");
            queue.offer(curr.left);
            queue.offer(curr.right);
        }
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data == null || data.length() == 0)
            return null;
        String[] nodes = data.split(",");
        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = new TreeNode(Integer.valueOf(nodes[0]));
        queue.offer(root);
        for (int i = 1; i < nodes.length; i++) {
            TreeNode curr = queue.poll();
            if (!nodes[i].equals("#")) {
                curr.left = new TreeNode(Integer.valueOf(nodes[i]));
                queue.offer(curr.left);
            }
            if (!nodes[++i].equals("#")) {
                curr.right = new TreeNode(Integer.valueOf(nodes[i]));
                queue.offer(curr.right);
            }
        }
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```


## Number of Islands

[Problem URL](https://leetcode.com/problems/number-of-islands/)

Description:

> Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
> 
> Example 1:
> 
> 11110
> 11010
> 11000
> 00000
> Answer: 1
> 
> Example 2:
> 
> 11000
> 11000
> 00100
> 00011
> Answer: 3

Solution1:
Time O(mn), space O(mn) (worst case, the grid is filled with lands, dfs needs to go m * n steps)
```java
char[][] g;
    
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0)
        return 0;
    int m = grid.length, n = grid[0].length;
    // prevent making "copy" during each recursion
    // reduce memory usage
    g = grid;
    int cnt = 0;
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (g[i][j] == '1') {
                dfsSink(i, j);
                cnt++;
            }
    return cnt;
}

private void dfsSink(int i, int j) {
    if (i < 0 || i >= g.length || j < 0 || j >= g[0].length
       || g[i][j] == '0')
        return;
    // mark current cell as visited
    g[i][j] = '0';
    dfsSink(i + 1, j);
    dfsSink(i - 1, j);
    dfsSink(i, j + 1);
    dfsSink(i, j - 1);
}
```

Solution2:
Time O(mn), space O(min(m, n)), because in worst case where the grid is filled with lands, the size of queue can grow up to min(m, n)

```java
// Time O(m * n)
// Space O(min(m, n)), worst case, all lands
// the currently enqueued lands go like diagonal line
// but still bounded by min(m, n)
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0)
        return 0;
    int m = grid.length, n = grid[0].length;
    int cnt = 0;
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (grid[i][j] == '1') {
                cnt++;
                // mark as visited
                grid[i][j] = '0';
                // create a queue for each island
                Queue<Integer> q = new LinkedList<>();
                // enqueue the current position                    
                q.offer(i * n + j);
                while (!q.isEmpty()) {
                    int pos = q.poll();
                    int r = pos / n;
                    int c = pos % n;
                    // visit four directions
                    if (r - 1 >= 0 && grid[r - 1][c] == '1') {
                        grid[r - 1][c] = '0';
                        q.offer((r - 1) * n + c);
                    }
                    if (r + 1 < m && grid[r + 1][c] == '1') {
                        grid[r + 1][c] = '0';
                        q.offer((r + 1) * n + c);
                    }
                    if (c - 1 >= 0 && grid[r][c - 1] == '1') {
                        grid[r][c - 1] = '0';
                        q.offer(r * n + c - 1);
                    }
                    if (c + 1 < n && grid[r][c + 1] == '1') {
                        grid[r][c + 1] = '0';
                        q.offer(r * n + c + 1);
                    }
                }
            }
    return cnt;
}
```


Solution3:
Union-find
Union by rank and path compression
Time O(mn), space O(mn)
```java
int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
int res = 0;
public int numIslands(char[][] grid) {
    if (grid == null || grid.length == 0 || grid[0].length == 0)
        return 0;
    int m = grid.length, n = grid[0].length;
    int[] roots = new int[m * n];
    int[] ranks = new int[m * n];
    // initialization
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (grid[i][j] == '1') {
                res++;
                int currIdx = i * n + j;
                roots[currIdx] = currIdx;
                ranks[currIdx] = 0;
            }
    
    for (int i = 0; i < m; i++)
        for (int j = 0; j < n; j++)
            if (grid[i][j] == '1') {
                int currIdx = i * n + j;
                grid[i][j] = '0';
                for (int[] dir : dirs) {
                    int x = i + dir[0], y = j + dir[1];
                    if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == '0')
                        continue;
                    union(roots, ranks, currIdx, x * n + y);
                }
            }
    return res;
}

private void union(int[] roots, int[] ranks, int currIdx, int neighborIdx) {
    int root1 = find(roots, currIdx);
    int root2 = find(roots, neighborIdx);
    if (root1 != root2) {
        // union by rank
        if (ranks[root1] > ranks[root2])
            roots[root2] = root1;
        else if (ranks[root1] < ranks[root2])
            roots[root1] = root2;
        else {
            roots[root2] = root1;
            ranks[root1]++;
        }
        res--;
    }
}

private int find(int[] roots, int idx) {
    while (idx != roots[idx]) {
        // path compression
        roots[idx] = roots[roots[idx]];
        idx = roots[idx];
    }
    return idx;
}
```


## Expression Add Operators

[Problem URL](https://leetcode.com/problems/expression-add-operators)

Description:

> Given a string that contains only digits 0-9 and a target value, return all possibilities to add binary operators (not unary) +, -, or * between the digits so they evaluate to the target value.
> 
> Examples:
> 
> "123", 6 -> ["1+2+3", "1*2*3"] 
> "232", 8 -> ["2*3+2", "2+3*2"]
> "105", 5 -> ["1*0+5","10-5"]
> "00", 0 -> ["0+0", "0-0", "0*0"]
> "3456237490", 9191 -> []


Solution:
Time O(4 ^ n):
T(n) = 3 * T(n-1) + 3 * T(n-2) + 3 * T(n-3) + ... + 3 *T(1);
T(n-1) = 3 * T(n-2) + 3 * T(n-3) + ... 3 * T(1);
Thus T(n) = 4T(n-1);

Space O(n)
```java
public List<String> addOperators(String num, int target) {
    List<String> res = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    backtrack(res, num.toCharArray(), sb, target, 0, 0, 0);
    return res;
}

/**
 * multi is the number to be multiplied
 */
private void backtrack(List<String> res, char[] num, StringBuilder sb, int target, int pos, long prev, long multi) {
    if (pos == num.length) {
        if (prev == target)
            res.add(sb.toString());
        return;
    }
    long curr = 0;
    for (int i = pos; i < num.length; i++) {
        curr = 10 * curr + (num[i] - '0');
        // deal with leading zero
        if (i != pos && num[pos] == '0')
            break;
        int len = sb.length();
        if (pos == 0) {
            backtrack(res, num, sb.append(curr), target, i + 1, curr, curr);
            sb.setLength(len);
        } else {
            // +
            backtrack(res, num, sb.append("+").append(curr), target, i + 1, prev + curr, curr);
            sb.setLength(len);
            // -
            backtrack(res, num, sb.append("-").append(curr), target, i + 1, prev - curr, -curr);
            sb.setLength(len);
            // *
            // e.g, sequence 12345, already processed 1 + 2 + 3, want to add * between 3 and 4
            // here prev = 6 (1 + 2 + 3), multi = 3, curr = 4
            // it becomes 1 + 2 + 3 - 3 + 3 * 4 = 1 + 2 + 3 * 4
            backtrack(res, num, sb.append("*").append(curr), target, i + 1, prev - multi + multi * curr, multi * curr);
            sb.setLength(len);
        }
    }
}
```


## Minimum Window Substring

[Problem URL](https://leetcode.com/problems/minimum-window-substring)

Description

> Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
> 
> For example,
> S = "ADOBECODEBANC"
> T = "ABC"
> 
> Minimum window is "BANC".
> 
> Note:
> If there is no such window in S that covers all characters in T, return the empty string "".
> 
> If there are multiple such windows, you are guaranteed that there will always be only one unique minimum window in S.


Solution:
Time O(n), space O(1)
```java
public String minWindow(String s, String t) {
    int[] freq = new int[256];
    // start, end, min length, start index of min length of the window
    int start = 0, end = 0, minLength = Integer.MAX_VALUE, minStart = 0;
    // #letters left to include in t
    int count = t.length();
    // store the frequency of letters in t
    for (char c : t.toCharArray())
        freq[c]++;
    while (end < s.length()) {
        // find one letter in t
        // increment the end of the window
        // decrement the frequency and the #letters left to match in t
        if (freq[s.charAt(end++)]-- > 0)
            count--;
        // while all letters in t are included
        // find the min length of the window
        while (count == 0) {
            if (end - start < minLength) {
                // update the min length if a shorter one is found
                // here end is increment by 1 previously
                // so no need to "+1" when computing the length
                minLength = end - start;
                minStart = start;
            }
            // narrow the left side to make the window invalid
            if (++freq[s.charAt(start++)] > 0)
                count++;
        }
    }
    return minLength == Integer.MAX_VALUE ? "" : s.substring(minStart, minStart + minLength);
}
```


## Binary Tree Paths

[Problem URL](https://leetcode.com/problems/binary-tree-paths/)

Description:

> Given a binary tree, return all root-to-leaf paths.
> For example, given the following binary tree:
> [1, 2, 3, null, 5]
> All root-to-leaf paths are: ["1->2->5", "1->3"]

Solution:
1.Based on preorder traversal
Version 1
```java
// preorder traversal
// Time O(n)
// space O(n)
public List<String> binaryTreePaths(TreeNode root) {
    // based on divide and conquer
    List<String> res = new ArrayList<String>();
    StringBuilder sb = new StringBuilder();
    binaryTreePathsHelper(res, root, sb);
    return res;
}

private void binaryTreePathsHelper(List<String> res, TreeNode root, StringBuilder sb) {
    if (root == null)
        return;
    int len = sb.length();
    sb.append(root.val);
    // reached a leaf
    if (root.left == null && root.right == null) {
        res.add(sb.toString());
    } else {
        sb.append("->");
        binaryTreePathsHelper(res, root.left, sb);
        binaryTreePathsHelper(res, root.right, sb);
    }
    sb.setLength(len);
}
```

Version 2
```java
public List<String> binaryTreePaths(TreeNode root) {
    // based on divide and conquer
    List<String> result = new ArrayList<String>();
    if (root != null) {
        binaryTreePathsHelper(root, result, "");
    }
    return result;
}

private void binaryTreePathsHelper(TreeNode root, List<String> result, String path) {
    if (root.left == null && root.right == null) {
        result.add(path + root.val);
    }
    if (root.left != null) {
        binaryTreePathsHelper(root.left, result, path + root.val + "->");
    }
    if (root.right != null) {
        binaryTreePathsHelper(root.right, result, path + root.val + "->");
    }
}
```

2. Divide and conquer
```java
public List<String> binaryTreePaths(TreeNode root) {
    // based on divide and conquer
    List<String> result = new ArrayList<String>();
    if (root == null) {
        return result;
    }
    // divide
    List<String> leftResult = binaryTreePaths(root.left);
    List<String> rightResult= binaryTreePaths(root.right);
    
    // conquer
    for (String path: leftResult) {
        result.add(root.val + "->" + path);
    }
    for (String path: rightResult) {
        result.add(root.val + "->" + path);
    }
    
    // if root is a leaf
    if (result.size() == 0) {
        result.add("" + root.val);
    }
    return result;
}
```


## Merge K Sorted Lists

[Problem URL](https://leetcode.com/problems/merge-k-sorted-lists)

Description:

> Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 

Solution1:
Time O(nklogk) (k is average length of each list, n is length of input array)
Space O(k)
```java
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0)
        return null;
    PriorityQueue<ListNode> pq = new PriorityQueue<>(lists.length, (n1, n2) -> (n1.val - n2.val));
    // enqueue all heads
    for (ListNode head : lists)
        if (head != null)
            pq.offer(head);
    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;
    while (!pq.isEmpty()) {
        tail.next = pq.poll();
        tail = tail.next;
        // enqueue the next node in that linkedlist
        if (tail.next != null)
            pq.offer(tail.next);
    }
    return dummy.next;
}
```


Solution2:
```java
// Time O(nklogk), k = lists.length, n = #nodes in each list
// each merge takes O(n), partition takes (logk)
// Space O(logk)
public ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0)
        return null;
    return partition(lists, 0, lists.length - 1);
}

private ListNode partition(ListNode[] lists, int lo, int hi) {
    if (lo == hi)
        return lists[lo];
    if (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        ListNode l1 = partition(lists, lo, mid);
        ListNode l2 = partition(lists, mid + 1, hi);
        return merge(l1, l2);
    } else {
        return null;
    }
}

private ListNode merge(ListNode l1, ListNode l2) {
    if (l1 == null)
        return l2;
    if (l2 == null)
        return l1;
    if (l1.val < l2.val) {
        l1.next = merge(l1.next, l2);
        return l1;
    } else {
        l2.next = merge(l1, l2.next);
        return l2;
    }
}
```


## Symmetric Tree

[Problem URL](https://leetcode.com/problems/symmetric-tree/)

Description:

> Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
> 
> For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
> 
> But the following [1,2,2,null,3,null,3] is not:
> 
> Note:
> Bonus points if you could solve it both recursively and iteratively.

Solution:

Recursive:
```java
// Time O(n)
// Because we traverse the entire input tree once, n is #nodes in the tree.
// Space O(h)
// #recursive calls is bound by the height of the tree. worst case h = n
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return helper(root.left, root.right);
}

public boolean helper(TreeNode left, TreeNode right) {
    if (left == null && right == null) {
        return true;
    }
    if (left == null || right == null) {
        return false;
    }
    if (left.val != right.val) {
        return false;
    }
    return helper(left.left, right.right) && helper(left.right, right.left);
}
```

Iterative:
```java
// Time O(n)
// Space O(n)
public boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root.left);
    queue.offer(root.right);
    while (!queue.isEmpty()) {
        TreeNode left = queue.poll();
        TreeNode right = queue.poll();
        if (left == null && right == null) {
            continue;
        }
        if (left == null || right == null) {
            return false;
        }
        if (left.val != right.val) {
            return false;
        }
        queue.offer(left.left);
        queue.offer(right.right);
        queue.offer(left.right);
        queue.offer(right.left);
    }
    return true;
}
```


## Diameter Of Binary Tree

[Problem URL](https://leetcode.com/problems/diameter-of-binary-tree)

> Description:
> 
> Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
> 
> Example:
> Given a binary tree
> 
>           1
>          / \
>         2   3
>        / \     
>       4   5    
> 
> Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
> 
> Note: The length of path between two nodes is represented by the number of edges between them.

Solution:
DFS, for each node, count the max length of from this subtree to its root
Time O(n), space O(n)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
int res;
public int diameterOfBinaryTree(TreeNode root) {
    res = 0;
    dfs(root);
    return res;
}

// returns max length from this subtree to its root
private int dfs(TreeNode node) {
    if (node == null)
        return 0;
    int left = dfs(node.left);
    int right = dfs(node.right);
    res = Math.max(res, left + right);
    // +1 is the max length of its subtree plus the edge from this node to its root
    return Math.max(left, right) + 1;
    }
```


```java
// time O(n), space O(n)
class Solution {
    int res;
    public int diameterOfBinaryTree(TreeNode root) {
        res = 0;
        dfs(root);
        return res;
    }
    
    // returns the height
    private int dfs(TreeNode node) {
        if (node == null)
            return -1;
        int left = dfs(node.left);
        int right = dfs(node.right);
        // +2 = 2 edges from left and right
        res = Math.max(res, left + right + 2);
        // +1 is the max length of its subtree plus the edge from this node to its root
        return Math.max(left, right) + 1;
    }
}
```


## Subtree Of Another Tree

[Problem URL](https://leetcode.com/problems/subtree-of-another-tree)

Description:

> Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.
> 
> Example 1:
> Given tree s:
> 
>      3
>     / \
>    4   5
>   / \
>  1   2
> 
> Given tree t:
> 
>    4 
>   / \
>  1   2
> 
> Return true, because t has the same structure and node values with a subtree of s.
> 
> Example 2:
> Given tree s:
> 
>      3
>     / \
>    4   5
>   / \
>  1   2
>     /
>    0
> 
> Given tree t:
> 
>    4
>   / \
>  1   2
> 
> Return false. 


Solution1:
DFS
Time O(n * m), n, m = #nodes in tree s, t
Space O(n), max step is n
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
// Time O(n * m), n, m = #nodes in tree s, t
// Space O(n), max step is n
public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null)
        return false;
    if (isSame(s, t))
        return true;
    return isSubtree(s.left, t) || isSubtree(s.right, t);
}

private boolean isSame(TreeNode s, TreeNode t) {
    if (s == null && t == null)
        return true;
    if (s == null || t == null)
        return false;
    if (s.val != t.val)
        return false;
    return isSame(s.left, t.left) && isSame(s.right, t.right);
}
```


Solution2:
Time O(n + m), n, m = #nodes in tree s, t (string.contains() is O(n))
Space O(n + m)
```java
public boolean isSubtree(TreeNode s, TreeNode t) {
    return serialize(s).contains(serialize(t));
}

private String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

private void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(",.");
        return;
    }
    sb.append(root.val).append(",");
    serialize(root.left, sb);
    serialize(root.right, sb);
}
```


## Shortest Unsorted Continuous Subarray

[Problem URL](https://leetcode.com/problems/shortest-unsorted-continuous-subarray)

Description:

> Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.
> 
> You need to find the shortest such subarray and output its length.
> 
> Example 1:
> Input: [2, 6, 4, 8, 10, 9, 15]
> Output: 5
> Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
> Note:
> Then length of the input array is in range [1, 10,000].
> The input array may contain duplicates, so ascending order here means <=.

Solution1:
Sort and compare
```java
// Time O(nlogn)
// Space O(n)
public int findUnsortedSubarray(int[] nums) {
    int n = nums.length;
    int[] nums_copy = new int[n];
    for (int i = 0; i < nums.length; i++)
        nums_copy[i] = nums[i];
    Arrays.sort(nums_copy);
    int i = 0, j = n - 1;
    // Compare with original array
    while (i < n && nums[i] == nums_copy[i])
        // find consistent elements from front
        i++;
    while (j > i && nums[j] == nums_copy[j])
        // find consistent elements from back
        j--;
    return j - i + 1;
}
```


Solution2:
```java
// Time O(n)
// Space O(1)
public int findUnsortedSubarray(int[] nums) {
    int n = nums.length;
    int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
    int start = -1, end = n - 1;
    for (int i = 0; i < n; i++) {
        // from left to right, search the current max
        // if in ASCE, then max will get larger
        max = Math.max(max, nums[i]);
        // from right to left, search the current min 
        // if in ASCE, min will get smaller
        min = Math.min(min, nums[n - i - 1]);  
        
        // in order part, update end
        if (nums[i] < max)  
            end = i;
        // out of order part, update start
        if (nums[n - i - 1] > min)
            start = n - i - 1;
    }
    
    if (start == -1) //the entire array is already sorted
        return 0;
    return end - start + 1;
}
```


## Remove Duplicates From Sorted Array

[Problem URL](https://leetcode.com/problems/remove-duplicates-from-sorted-array)

Description:

> Given a sorted array, remove the duplicates in-place such that each element appear only once and return the new length.
> 
> Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
> 
> Example:
> 
> Given nums = [1,1,2],
> 
> Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.
> It doesn't matter what you leave beyond the new length.


Solution:
Time O(n), space O(1)
```java
public int removeDuplicates(int[] nums) {
    int len = 0;
    for (int i = 0; i < nums.length; i++)
        if (i == 0 || nums[i] != nums[i - 1])
            nums[len++] = nums[i];
    return len;
}
```


## Remove Duplicates From Sorted Array II

[Problem URL](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii)

Description:

> Follow up for "Remove Duplicates":
> What if duplicates are allowed at most twice?
> 
> For example,
> Given sorted array nums = [1,1,1,2,2,3],
> 
> Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3. It doesn't matter what you leave beyond the new length. 


Solution:
Time O(n), space O(1)
```java
// Time O(n)
// Space O(1)
public int removeDuplicates(int[] nums) {
    int n = nums.length;
    if (n <= 2)
        return n;
    int count = 1, len = 1;
    for (int i = 1; i < n; i++) {
        if (nums[i - 1] != nums[i]) {
            // different, reset count
            // add current number
            count = 1;
            nums[len++] = nums[i];
        } else {
            if (count < 2) {
                count++;
                nums[len++] = nums[i];
            }
        }
    }
    return len;
}
```


## Excel Sheet Column Title

[Problem URL](https://leetcode.com/problems/excel-sheet-column-title)

Description:

> Given a positive integer, return its corresponding column title as appear in an Excel sheet.
> 
> For example:
> 
>     1 -> A
>     2 -> B
>     3 -> C
>     ...
>     26 -> Z
>     27 -> AA
>     28 -> AB

Solution:
```java
// Time O(n / 26) = O(n)
// Space O(n / 26) = O(n)
public String convertToTitle(int n) {
    StringBuilder strb = new StringBuilder();
    while (n > 0) {
        // we use 'A' as a base, so -1 here
        // e.g. 'Z' = 26, 25 % 26 = 25, 'A' + 25 = 'Z'
        int curr = (n - 1) % 26;
        strb.append((char)('A' + curr));
        n = (n - curr) / 26;
    }
    return strb.reverse().toString();
}
```


## One Edit Distance

[Problem URL](https://leetcode.com/problems/one-edit-distance)

Description:

> Given two strings S and T, determine if they are both one edit distance apart.

Solution:
```java
// 3 cases:
// (1) replace one letter from s
// (2) delete one letter from s
// (3) delete one letter from t

// time O(n), although substring() and equals() are both O(n), but they are called only at one place
// space O(1)
public boolean isOneEditDistance(String s, String t) {
    if (s.equals(t))
        return false;
    for (int i = 0; i < Math.min(s.length(), t.length()); i++) {
        if (s.charAt(i) != t.charAt(i)) {
            if (s.length() == t.length())
                // case 1, check rest
                return s.substring(i + 1).equals(t.substring(i + 1));
            // case 2
            else if (s.length() > t.length())
                return s.substring(i + 1).equals(t.substring(i));
            else // case 3
                return s.substring(i).equals(t.substring(i + 1));
        }
    }
    // all previous letters are same, check if lengths only differ by 1
    // (a string has one more char at end)
    return Math.abs(s.length() - t.length()) == 1;
}
```


## Best Time to Buy and Sell Stock

[Problem URL](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

Description:

> Say you have an array for which the ith element is the price of a given stock on day i.
> 
> If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
> 
> Example 1:
> Input: [7, 1, 5, 3, 6, 4]
> Output: 5
> 
> max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
> Example 2:
> Input: [7, 6, 4, 3, 1]
> Output: 0
> 
> In this case, no transaction is done, i.e. max profit = 0.

Solution:

```java
// Time O(n)
// Space O(1)
public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int profit = 0;
    int min = prices[0];
    for (int i = 1; i < prices.length; i++) {
        profit = Math.max(profit, prices[i] - min);
        min = Math.min(min, prices[i]);
    }
    return profit;
}
```


## Construct The Rectangle

[Problem URL](https://leetcode.com/problems/construct-the-rectangle)

Description:

> For a web developer, it is very important to know how to design a web page's size. So, given a specific rectangular web pageâ€™s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:
> 
> 1. The area of the rectangular web page you designed must equal to the given target area.
> 
> 2. The width W should not be larger than the length L, which means L >= W.
> 
> 3. The difference between length L and width W should be as small as possible.
> You need to output the length L and the width W of the web page you designed in sequence.
> Example:
> Input: 4
> Output: [2, 2]
> Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. 
> But according to requirement 2, [1,4] is illegal; according to requirement 3,  [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2.
> Note:
> The given area won't exceed 10,000,000 and is a positive integer
> The web page's width and length you designed must be positive integers.

Solution:
```java
// Time O(sqrt(area)), worst case area is prime, need to loop from w to 1
// Space O(1)
public int[] constructRectangle(int area) {
    int w = (int)Math.sqrt(area);
    while (area % w != 0)
        w--;
    return new int[] {area / w, w};
}
```


## Combination Sum

[Problem URL](https://leetcode.com/problems/combination-sum)

Description:

> Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
> 
> The same repeated number may be chosen from C unlimited number of times.
> 
> Note:
> 
>     All numbers (including target) will be positive integers.
>     The solution set must not contain duplicate combinations.
> 
> For example, given candidate set [2, 3, 6, 7] and target 7,
> A solution set is:
> 
> [
>   [7],
>   [2, 2, 3]
> ]


Solution:
classic backtracking, time O(2 ^ n), space O(n)
```java
public List<List<Integer>> combinationSum(int[] candidates, int target) {
    List<List<Integer>> res = new ArrayList<>();
    if (candidates == null || candidates.length == 0)
        return res;
    Arrays.sort(candidates);
    backtrack(res, candidates, target, new ArrayList<>(), 0);
    return res;
}

private void backtrack(List<List<Integer>> res, int[] candidates, int remain, List<Integer> curr, int index) {
    if (remain < 0)
        return;
    if (remain == 0) {
        res.add(new ArrayList<>(curr));
        return;
    }
    for (int i = index; i < candidates.length; i++) {
        curr.add(candidates[i]);
        backtrack(res, candidates, remain - candidates[i], curr, i);
        curr.remove(curr.size() - 1);
    }
}
```


## Combination Sum II

[Problem URL](https://leetcode.com/problems/combination-sum-ii)

Description:

> Given a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.
> 
> Each number in C may only be used once in the combination.
> 
> Note:
> 
>     All numbers (including target) will be positive integers.
>     The solution set must not contain duplicate combinations.
> 
> For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,
> A solution set is:
> 
> [
>   [1, 7],
>   [1, 2, 5],
>   [2, 6],
>   [1, 1, 6]
> ]


Solution:
Classic backtracking, time O(2 ^ n), space O(n)
```java
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
    List<List<Integer>> res = new ArrayList<>();
    Arrays.sort(candidates);
    backtrack(res, candidates, target, 0, new ArrayList<>());
    return res;
}

private void backtrack(List<List<Integer>> res, int[] candidates, int remain, int start, List<Integer> curr) {
    if (remain == 0) {
        res.add(new ArrayList<>(curr));
        return;
    }
    if (remain < 0)
        return;
    for (int i = start; i < candidates.length; i++) {
        if (i == start || candidates[i] != candidates[i - 1]) {
            curr.add(candidates[i]);
            backtrack(res, candidates, remain - candidates[i], i + 1, curr);
            curr.remove(curr.size() - 1);
        }
    }
}
```


## Combination Sum III

[Problem URL](https://leetcode.com/problems/combination-sum-iii)

Description:

> Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
> 
> Example 1:
> 
> Input: k = 3, n = 7
> 
> Output:
> 
> [[1,2,4]]
> 
> 
> Example 2:
> 
> Input: k = 3, n = 9
> 
> Output:
> 
> [[1,2,6], [1,3,5], [2,3,4]]


Solution:
```java
// Time O(C(9, k)), worst case = combination of picking k numbers from 9 digits
// Space O(9) = O(1), max depth is 9
public List<List<Integer>> combinationSum3(int k, int n) {
    List<List<Integer>> res = new ArrayList<>();
    backtrack(res, k, n, 1, new ArrayList<>());
    return res;
}

private void backtrack(List<List<Integer>> res, int k, int remain, int start, List<Integer> curr) {
    if (k == 0 && remain == 0 ) {
        res.add(new ArrayList<>(curr));
        return;
    }
    if (k == 0)
        return;
    for (int i = start; i <= 9; i++) {
        curr.add(i);
        backtrack(res, k - 1, remain - i, i + 1, curr);
        curr.remove(curr.size() - 1);
    }
}
```


## Combination Sum IV

[Problem URL](https://leetcode.com/problems/combination-sum-iv/)

Description:

> Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.
> 
> Example:
> 
> nums = [1, 2, 3]
> target = 4
> 
> The possible combination ways are:
> (1, 1, 1, 1)
> (1, 1, 2)
> (1, 2, 1)
> (1, 3)
> (2, 1, 1)
> (2, 2)
> (3, 1)
> 
> Note that different sequences are counted as different combinations.
> 
> Therefore the output is 7.
> 
> Follow up:
> What if negative numbers are allowed in the given array?
> How does it change the problem?
> What limitation we need to add to the question to allow negative numbers?
 
Solution:
Bottom-up DP, time O(kn) (k is target), space O(k)
```java
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    for (int i = 1; i < dp.length; i++)
        for (int num : nums)
            if (i >= num)
                dp[i] += dp[i - num];
    return dp[target];
}
```

Top-down DP
```java
// Time O(n * k), k = target, only needs to fill the dp array once,
// but for each recursion, it takes O(n)
// Space O(k)
public int combinationSum4(int[] nums, int target) {
    // dp[i] = #combs to get sum i
    int[] dp = new int[target + 1];
    Arrays.fill(dp, -1);
    dp[0] = 1;
    return helper(nums, target, dp);
}

private int helper(int[] nums, int target, int[] dp) {
    if (dp[target] != -1)
        return dp[target];
    int res = 0;
    for (int num : nums)
        if (target >= num)
            res += helper(nums, target - num, dp);
    dp[target] = res;
    return res;
}
```

Solution3:
Optimized bottom-up dp
```java
// Bottom-up DP
// Time O(kn + nlogn) (k is target)
// Space O(k)
public int combinationSum4(int[] nums, int target) {
    int[] dp = new int[target + 1];
    dp[0] = 1;
    Arrays.sort(nums);
    for (int i = 1; i < dp.length; i++)
        for (int num : nums)
            if (i >= num)
                dp[i] += dp[i - num];
            else
                break;
    return dp[target];
}
```


## Permutations

[Problem URL](https://leetcode.com/problems/permutations)

Description:

> Given a collection of distinct numbers, return all possible permutations.
> 
> For example,
> [1,2,3] have the following permutations:
> 
> [
>   [1,2,3],
>   [1,3,2],
>   [2,1,3],
>   [2,3,1],
>   [3,1,2],
>   [3,2,1]
> ]


Solution:
Classic backtracking, use a boolean array to mark which element is used
Time O(n!), space O(n)

```java
public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    boolean[] used = new boolean[nums.length];
    backtrack(res, nums, used, new ArrayList<>());
    return res;
}

private void backtrack(List<List<Integer>> res, int[] nums, boolean[] used, List<Integer> curr) {
    if (curr.size() == nums.length) {
        res.add(new ArrayList<>(curr));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (used[i])
            continue;
        curr.add(nums[i]);
        used[i] = true;
        backtrack(res, nums, used, curr);
        curr.remove(curr.size() - 1);
        used[i] = false;
    }
        
}
```


## Permutations II

[Problem URL](https://leetcode.com/problems/permutations-ii)

Description:

> Given a collection of numbers that might contain duplicates, return all possible unique permutations.
> 
> For example,
> [1,1,2] have the following unique permutations:
> 
> [
>   [1,1,2],
>   [1,2,1],
>   [2,1,1]
> ]


Solution:
Classic backtracking, use a boolean array to mark used elements. Sort by computing to make duplicates next to each other.
```java
// Time, still (n!), n = nums.length
// Space O(n)
public List<List<Integer>> permuteUnique(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    boolean[] used = new boolean[nums.length];
    Arrays.sort(nums);
    backtrack(res, nums, used, new ArrayList<>());
    System.out.println(res.size());
    return res;
}

private void backtrack(List<List<Integer>> res, int[] nums, boolean[] used, List<Integer> curr) {
    if (curr.size() == nums.length) {
        res.add(new ArrayList<>(curr));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        // avoid duplications in permutations
        if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]))
            continue;
        curr.add(nums[i]);
        used[i] = true;
        backtrack(res, nums, used, curr);
        curr.remove(curr.size() - 1);
        used[i] = false;
    }
}
```


## Summary Ranges

[Problem URL](https://leetcode.com/problems/summary-ranges)

Description:

> Given a sorted integer array without duplicates, return the summary of its ranges.
> 
> Example 1:
> Input: [0,1,2,4,5,7]
> Output: ["0->2","4->5","7"]
> Example 2:
> Input: [0,2,3,4,6,8,9]
> Output: ["0","2->4","6","8->9"]


Solution:
```java
// Time O(n)
// Space O(1)
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();
    // i, j are start, end of range
    for (int i = 0, j = 0; j < nums.length; j++) {
        if (j + 1 < nums.length && nums[j] + 1 == nums[j + 1])
            continue;
        // single disjoint number
        if (i == j)
            res.add(nums[i] + "");
        else
            res.add(nums[i] + "->" + nums[j]);
        // update start
        i = j + 1;
    }
    return res;
}
```


## Simple Encode String Shorter

> Not a leet code problem, basically encode string from "aaabccccc" -> "3ab5c"
> Only return the encoded string if it is shorter in length

Solution:
```java
public String encode(String word) {
    StringBuilder enc = new StringBuilder();
    int n = word.length();
    // start from 1 end with n
    // because needs to check all previous letters
    for (int i = 1, cnt = 1; i <= n; i++, cnt++) {
        if (i == n || word.charAt(i - 1) != word.charAt(i)) {
            if (cnt > 1) {
                enc.append(cnt);
            }
            enc.append(word.charAt(i - 1));
            cnt = 0;
        }
    }
    return enc.length() < word.length() ? enc.toString() : word;
}
```


## Minimum Size Subarray Sum

[Problem URL](https://leetcode.com/problems/minimum-size-subarray-sum/)

Description:

> Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum â‰¥ s. If there isn't one, return 0 instead.
> 
> For example, given the array [2,3,1,2,4,3] and s = 7,
> the subarray [4,3] has the minimal length under the problem constraint.


Solution1:
```java
// Time O(nlogn)
// Space O(n)
public int minSubArrayLen(int s, int[] nums) {
    // binary search based solution
    // get the accumulated summations,
    // which will be the searching space
    int[] sums = new int[nums.length + 1];
    for (int i = 1; i < sums.length; i++) {
        sums[i] = nums[i - 1] + sums[i - 1];
    }
    int minLen = Integer.MAX_VALUE;
    for (int i = 0; i < sums.length; i++) {
        // search for the position that the cumulative sum >=
        // sums[i] + s
        int end = binarySearch(i + 1, sums.length - 1, sums[i] + s, sums);
        // stop if no such position
        if (end == sums.length) {
            break;
        }
        // get the min length
        if (end - i < minLen) {
            minLen = end - i;
        }
    }
    return minLen == Integer.MAX_VALUE ? 0 : minLen;
}

private int binarySearch(int lo, int hi, int val, int[] sums) {
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (sums[mid] >= val) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return val <= sums[sums.length - 1] ? lo : sums.length;
}
```


Solution2:
```java
// Time O(n), each num is visited at most twice (i and start)
// Space O(1)
public int minSubArrayLen(int s, int[] nums) {
    int min = Integer.MAX_VALUE;
    int start = 0, sum = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += nums[i];
        while (sum >= s) {
            // shrink sum and increase the start border
            min = Math.min(min, i - start + 1);
            sum -= nums[start++];
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;
}
```


## Simplify Path

[Problem URL](https://leetcode.com/problems/simplify-path)

Description:

> Given an absolute path for a file (Unix-style), simplify it.
> 
> For example,
> path = "/home/", => "/home"
> path = "/a/./b/../../c/", => "/c"
> 
> click to show corner cases.
> Corner Cases:
> 
>     Did you consider the case where path = "/../"?
>     In this case, you should return "/".
>     Another corner case is the path might contain multiple slashes '/' together, such as "/home//foo/".
>     In this case, you should ignore redundant slashes and return "/home/foo".

Solution1:
"." means current direction
".." means parent direction
"/home/" split("/") = ["", "home"]
    
Time O(n), space O(n)
```java
public String simplifyPath(String path) {
    StringBuilder sb = new StringBuilder();
    Deque<String> stack = new LinkedList<>();
    for (String dir : path.split("/")) {
        // go back to parent direction
        if (dir.equals("..")) {
            if (!stack.isEmpty())
                stack.pollLast();
        } else if (!dir.equals(".") && !dir.equals("")) {
            stack.offerLast(dir);
        }
    }
    if (stack.isEmpty())
        return "/";
    while (!stack.isEmpty()) {
        sb.append("/");
        sb.append(stack.pollFirst());
    }
    return sb.toString();
}
```


Solution2:
Time O(n)
Space O(n)
```java
public String simplifyPath(String path) {
    StringBuilder sb = new StringBuilder();
    LinkedList<String> stack = new LinkedList<>();
    // get each direction
    for (String dir : path.split("/")) {
        // go back to parent direction
        if (dir.equals("..")) {
            if (!stack.isEmpty())
                stack.removeLast();
        } else if (!dir.equals(".") && !dir.equals("")) {
            // "." is current direction, skip
            // multiple "//" will result in "" after split
            stack.add(dir);
        }
    }
    for (String dir : stack)
        sb.append("/").append(dir);
    // stack.isEmpty() when path = "/../" or similar
    return stack.isEmpty() ? "/" : sb.toString();
}
```


## Wildcard Matching

[Problem URL](https://leetcode.com/problems/wildcard-matching/description/)

Description:

> Implement wildcard pattern matching with support for '?' and '*'.
> 
> '?' Matches any single character.
> '*' Matches any sequence of characters (including the empty sequence).
> 
> The matching should cover the entire input string (not partial).
> 
> The function prototype should be:
> bool isMatch(const char *s, const char *p)
> 
> Some examples:
> isMatch("aa","a") â†’ false
> isMatch("aa","aa") â†’ true
> isMatch("aaa","aa") â†’ false
> isMatch("aa", "*") â†’ true
> isMatch("aa", "a*") â†’ true
> isMatch("ab", "?*") â†’ true
> isMatch("aab", "c*a*b") â†’ false


Solution1:
Bottom-up dp, time O(mn), space O(mn)
```java
// Time O(m * n)
// Space O(m * n)
public boolean isMatch(String s, String p) {
    int m = s.length(), n = p.length();
    // dp[i][j] = matching result of s[0..i - 1] with p[0..j - 1]
    boolean[][] dp = new boolean[m + 1][n + 1];
    dp[0][0] = true;
    // initialization for '*' matching empty strings
    for (int j = 1; j <= n; j++)
        if (p.charAt(j - 1) == '*')
            dp[0][j] = true;
        else
            break;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++) {
            if (p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1))
                dp[i][j] = dp[i - 1][j - 1];
            else if (p.charAt(j - 1) == '*') // match '*' as empty or multiple chars
                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
        }
    return dp[m][n];
}
```

Solution2:
```java
// Time O(m * n)
// Space O(n)
public boolean isMatch(String s, String p) {
    int m = s.length(), n = p.length();
    // dp[i][j] = matching result of s[0..i - 1] with p[0..j - 1]
    boolean[] dp = new boolean[n + 1];
    dp[0] = true;
    // initialization for '*' matching empty strings
    for (int j = 1; j <= n; j++)
        if (p.charAt(j - 1) == '*')
            dp[j] = true;
        else
            break;
    // pre = dp[i - 1][j - 1]
    // cur = dp[i - 1][j]
    boolean pre = dp[0], cur;
    for (int i = 1; i <= m; i++) {
        pre = dp[0];
        dp[0] = false;
        for (int j = 1; j <= n; j++) {
            cur = dp[j];
            if (p.charAt(j - 1) == '?' || s.charAt(i - 1) == p.charAt(j - 1))
                // match
                dp[j] = pre;
            else if (p.charAt(j - 1) == '*')
                // match '*' as empty or multiple chars
                dp[j] = dp[j - 1] || cur;
            else // mismatch
                dp[j] = false;
            pre = cur;
        }
    }
    return dp[n];
}
```


Solution3:
```java
// Time O(m * n), worst case "bbbbbbbbbbbb" and "*bbbb"
// Space O(1)
public boolean isMatch(String s, String p) {
    int sPtr = 0, pPtr = 0, starIdx = -1, lastMatched = 0;
    int m = s.length(), n = p.length();
    while (sPtr < m) {
        // System.out.println(sPtr + " " + pPtr);
        // if (pPtr < n)
        //     System.out.println(s.charAt(sPtr) + " " + p.charAt(pPtr));
        // else
        //     System.out.println(s.charAt(sPtr) + " @");
        // match, advance both pointers
        if (pPtr < n && (p.charAt(pPtr) == '?' || p.charAt(pPtr) == s.charAt(sPtr))) {
            sPtr++;
            pPtr++;
        } else if (pPtr < n && p.charAt(pPtr) == '*') {
            // encounter '*', mark current position, only advance pattern pointer
            starIdx = pPtr++;
            lastMatched = sPtr;
        } else if (starIdx != -1) {
            // previously met '*', currently is a mismatch,
            // or pattern pointer is out of bound
            // meaning, '*' may match muliple cases,
            // current patter pointer is out of bound
            // anadvance string pointer
            // advance pattern pointer from last '*'
            pPtr = starIdx + 1;
            sPtr = ++lastMatched;
        } else { // mismatch (no previous '*')
            return false;
        }
    }
    // deal with rest of '*'s
    while (pPtr < n && p.charAt(pPtr) == '*')
        pPtr++;
    return pPtr == n;
}
```



## Insert Delete Getrandom O1

[Problem URL](https://leetcode.com/problems/insert-delete-getrandom-o1)

Description:

> Design a data structure that supports all following operations in average O(1) time.
> 
>     insert(val): Inserts an item val to the set if not already present.
>     remove(val): Removes an item val from the set if present.
>     getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
> 
> Example:
> 
> // Init an empty set.
> RandomizedSet randomSet = new RandomizedSet();
> 
> // Inserts 1 to the set. Returns true as 1 was inserted successfully.
> randomSet.insert(1);
> 
> // Returns false as 2 does not exist in the set.
> randomSet.remove(2);
> 
> // Inserts 2 to the set, returns true. Set now contains [1,2].
> randomSet.insert(2);
> 
> // getRandom should return either 1 or 2 randomly.
> randomSet.getRandom();
> 
> // Removes 1 from the set, returns true. Set now contains [2].
> randomSet.remove(1);
> 
> // 2 was already in the set, so return false.
> randomSet.insert(2);
> 
> // Since 2 is the only number in the set, getRandom always return 2.
> randomSet.getRandom();


Solution:
Time: all O(1)
Space:
RandomizedSet(): O(1)
insert(), remove(), getRandom(), O(n), n is current size of the list

```java
class RandomizedSet {
    // a map of a val to its index in the list
    Map<Integer, Integer> valToIdx;
    // we need a list because we need to return an element
    // a set cannot do that
    List<Integer> nums;
    Random rand;
    
    /** Initialize your data structure here. */
    public RandomizedSet() {
        valToIdx = new HashMap<>();
        nums = new ArrayList<>();
        rand = new Random();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if (valToIdx.containsKey(val))
            return false;
        valToIdx.put(val, nums.size());
        nums.add(val);
        return true;
    }
    
/** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if (!valToIdx.containsKey(val))
            return false;
        int valIdx = valToIdx.get(val);
        if (valIdx < nums.size() - 1) {
            // achieve O(1) deletion by "swapping" last element
            // to the index val is at, then delete last element (takes O(1))
            int lastNum = nums.get(nums.size() - 1);
            valToIdx.put(lastNum, valIdx);
            nums.set(valIdx, lastNum);
        }
        nums.remove(nums.size() - 1);
        valToIdx.remove(val);
        return true;
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        int randomIdx = rand.nextInt(nums.size());
        return nums.get(randomIdx);
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

Follow-up: allow duplicates in the set
```java
class RandomizedSet {
    // a map of a val to its index in the list
    Map<Integer, Set<Integer>> valToIdx;
    // we need a list because we need to return an element
    // a set cannot do that
    List<Integer> nums;
    Random rand;
    
    /** Initialize your data structure here. */
    public RandomizedSet() {
        valToIdx = new HashMap<>();
        nums = new ArrayList<>();
        rand = new Random();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if (valToIdx.containsKey(val))
            return false;
        valToIdx.putIfAbsent(val, new HashSet<>());
        valToIdx.get(val).add(nums.size());
        nums.add(val);
        return true;
    }
    
/** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if (!valToIdx.containsKey(val))
            return false;
        int valIdx = valToIdx.get(val).iterator.next();
        if (valIdx < nums.size() - 1) {
            // achieve O(1) deletion by "swapping" last element
            // to the index val is at, then delete last element (takes O(1))
            int lastNum = nums.get(nums.size() - 1);
            nums.set(valIdx, lastNum);
            valToIdx.get(lastNum).remove(nums.size() - 1);
            valToIdx.get(lastNum).add(valIdx);
        }
        nums.remove(nums.size() - 1);
        if (valToIdx.get(val).isEmpty())
            valToIdx.remove(val);
        return true;
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        int randomIdx = rand.nextInt(nums.size());
        return nums.get(randomIdx);
    }
}
```


## Longest Consecutive Sequence

[Problem URL](https://leetcode.com/problems/longest-consecutive-sequence)

Description:

> Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
> 
> For example,
> Given [100, 4, 200, 1, 3, 2],
> The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
> 
> Your algorithm should run in O(n) complexity.


Solution1:
```java
// Time O(n)
// Space O(n)
public int longestConsecutive(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    HashSet<Integer> set = new HashSet<>();
    for (int n: nums)
        set.add(n);
    int res = 1;
    while (!set.isEmpty()) {
        // find new start point
        Iterator itr = set.iterator();
        int item = (Integer)itr.next();
        set.remove(item);
        // reset length
        int len = 1;
        // expand to smaller side
        int temp = item - 1;
        while (set.contains(temp)) {
            set.remove(temp--);
            len++;
        }
        // expand to larger side
        temp = item + 1;
        while (set.contains(temp)) {
            set.remove(temp++);
            len++;
        }
        res = Math.max(res, len);
    }
    return res;
}
```


Solution2:
```java
// Time O(n)
// Space O(n)
public int longestConsecutive(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    Set<Integer> num_set = new HashSet<Integer>();
    for (int num : nums) {
        num_set.add(num);
    }

    int longestStreak = 0;

    for (int num : num_set) {
        // find a smallest point as starting point
        if (!num_set.contains(num-1)) {
            int currentNum = num;
            int currentStreak = 1;

            while (num_set.contains(currentNum+1)) {
                currentNum += 1;
                currentStreak += 1;
            }

            longestStreak = Math.max(longestStreak, currentStreak);
        }
    }

    return longestStreak;
}
```


Solution3:
```java
// Time O(nlogn)
// Space O(1)
public int longestConsecutive(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    Arrays.sort(nums);

    int longestStreak = 1;
    int currentStreak = 1;

    for (int i = 1; i < nums.length; i++) {
        // skip dups
        if (nums[i] != nums[i-1]) {
            if (nums[i] == nums[i - 1] + 1) {
                currentStreak += 1;
            }
            else {
                longestStreak = Math.max(longestStreak, currentStreak);
                currentStreak = 1;
            }
        }
    }
    return Math.max(longestStreak, currentStreak);
}
```


## Add Digits

[Problem URL](https://leetcode.com/problems/add-digits)

Description:

> Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
> 
> For example:
> 
> Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.
> 
> Follow up:
> Could you do it without any loop/recursion in O(1) runtime?

Solution1:
```java
// Time O()
// Space O(1)
public int addDigits(int num) {
    int temp = num;
    int sum = 0;
    while (true) {
        while (temp != 0) {
            sum = sum + temp % 10;
            temp = temp / 10;
        }
        if (sum / 10 == 0) {
            return sum;
        } else {
            temp = sum;
            sum = 0;
        }            
    }      
}
```

Solution2:
```java
// Time O(1)
// Space O(1)
public int addDigits(int num) {
    // For base b (decimal case b = 10), the digit root of an integer is:
    // dr(n) = 0 if n == 0
    // dr(n) = (b-1) if n != 0 and n % (b-1) == 0
    // dr(n) = n mod (b-1) if n % (b-1) != 0
    // or
    // dr(n) = 1 + (n - 1) % 9
    return 1 + (num - 1) % 9;
}
```


## Total Hamming Distance

[Problem URL](https://leetcode.com/problems/total-hamming-distance)

Description:

> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
> 
> Now your job is to find the total Hamming distance between all pairs of the given numbers.
> 
> Example:
> 
> Input: 4, 14, 2
> 
> Output: 6
> 
> Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
> showing the four bits relevant in this case). So the answer will be:
> HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
> 
> Note:
> 
>     Elements of the given array are in the range of 0 to 10^9
>     Length of the array will not exceed 10^4.

Solution:
Time O(n), space O(1)
```java
public int totalHammingDistance(int[] nums) {
    int res = 0, n = nums.length;
    // 32 bit integers
    for (int i = 0; i < 32; i++) {
        int bitCount = 0;
        for (int j = 0; j < n; j++)
            // count #integers have that bit set
            bitCount += (nums[j] >> i) & 1;
        // assume bitCount = k
        // total combinations = C(k, 1) * C((n - k), 1)
        res += bitCount * (n - bitCount);
    }
    return res;
}
```


## Accounts Merge

[Problem URL](https://leetcode.com/problems/accounts-merge/)

Description:

> Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.
> 
> Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.
> 
> After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.
> 
> Example 1:
> 
> Input: 
> accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]
> Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]
> Explanation: 
> The first and third John's are the same person as they have the common email "johnsmith@mail.com".
> The second John and Mary are different people as none of their email addresses are used by other accounts.
> We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
> ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
> 
> Note:
> The length of accounts will be in the range [1, 1000].
> The length of accounts[i] will be in the range [1, 10].
> The length of ac
> counts[i][j] will be in the range [1, 30].


Solution:
Modified union-find, use TreeSet for sorting
Time, space, not sure
```java
// Time O(n * m * O(alpha(n * m))), n = accounts.size(), m = avg account[i].size()
// alpha() is inverse Ackermann function
// Space O(n * m)
public List<List<String>> accountsMerge(List<List<String>> accounts) {
    List<List<String>> res = new ArrayList<>();
    if (accounts == null || accounts.size() == 0)
        return res;
    Map<String, String> emailToName = new HashMap<>(); 
    // key email, value name
    Map<String, String> root = new HashMap<>();
    Map<String, TreeSet<String>> union = new HashMap<>();
    for (List<String> account : accounts) {
        String name = account.get(0);
        for (int i = 1; i < account.size(); i++) {
            String currEmail = account.get(i);
            emailToName.put(currEmail, name);
            // init root
            root.put(currEmail, currEmail);
        }
    }
    // union
    for (List<String> account : accounts) {
        String p = find(account.get(1), root);
        for (int i = 2; i < account.size(); i++) {
            root.put(find(account.get(i), root), p);
        }
    }
    // get emails with the same parent in the same set (sorted with TreeSet)
    for (List<String> account : accounts) {
        String p = find(account.get(1), root);
        for (int i = 1; i < account.size(); i++) {
            union.putIfAbsent(p, new TreeSet<>());
            union.get(p).add(account.get(i));
        }
    }
    for (String email : union.keySet()) {
        List<String> mergedAccount = new ArrayList<>(union.get(email));
        mergedAccount.add(0, emailToName.get(email));
        res.add(mergedAccount);
    }
    return res;
}

private String find(String email, Map<String, String> root) {
    while (!email.equals(root.get(email))) {
        // path compression
        root.put(email, root.get(root.get(email)));
        email = root.get(email);
    }
    return email;
}
```


Solution2:
Modified dfs, maintain email-name relationships, use emails as vertices
Time O(sum(alpha[i] * log alpha[i])), alpha[i] is the length of accounts[i]. Without the log factor, this is the complexity to build the graph and search for each component. The log factor is for sorting each component at the end.

Space O(sum(alpha[i])), the space used by graph and search.
```java
public List<List<String>> accountsMerge(List<List<String>> accounts) {
    List<List<String>> res = new ArrayList<>();
    if (accounts == null || accounts.size() == 0)
        return res;
    Map<String, String> emailToName = new HashMap<>();
    Map<String, Set<String>> emailGraph = new HashMap<>();
    // build email-name relationship and email-email graph
    for (List<String> account : accounts) {
        String name = account.get(0);
        for (int i = 1; i < account.size(); i++) {
            String currEmail = account.get(i);
            emailToName.put(account.get(i), name);
            emailGraph.putIfAbsent(currEmail, new HashSet<>());
            if (i == 1)
                continue;
            String prevEmail = account.get(i - 1);
            // connect adjacent emails
            emailGraph.get(prevEmail).add(currEmail);
            emailGraph.get(currEmail).add(prevEmail);
        }
    }
    // dfs
    Set<String> visited = new HashSet<>();
    for (String email : emailGraph.keySet()) {
        if (visited.contains(email))
            continue;
        List<String> mergedAccount = new ArrayList<>();
        visited.add(email);
        mergedAccount.add(email);
        dfs(emailGraph, mergedAccount, visited, email);
        Collections.sort(mergedAccount);
        mergedAccount.add(0, emailToName.get(email));
        res.add(mergedAccount);
    }
    return res;
}

private void dfs(Map<String, Set<String>> emailGraph, List<String> mergedAccount, Set<String> visited, String email) {
    for (String neighbor : emailGraph.get(email)) {
        if (visited.contains(neighbor))
            continue;
        visited.add(neighbor);
        mergedAccount.add(neighbor);
        dfs(emailGraph, mergedAccount, visited, neighbor);
    }
}
```


## Implement Trie Prefix Tree

[Problem URL](https://leetcode.com/problems/implement-trie-prefix-tree)

Description:

> Implement a trie with insert, search, and startsWith methods.
> 
> Note:
> You may assume that all inputs are consist of lowercase letters a-z.

Solution:
```java
class TrieNode {
    // Initialize your data structure here.
    private final int MAXSIZE = 26;
    public int count;
    public char val;
    public TrieNode[] children;
    public boolean isEnd;
    public TrieNode() {
        count = 1;
        children = new TrieNode[MAXSIZE];
        isEnd = false;
    }
}

// Time:
// insert(): O(n), n = word.length(),
// search(): O(n)
// startsWith(): O(m), m = prefix.length()
// 
// Space:
// insert(): O(n), if word doesn't share a same prefix, need to add n new nodes
// search(): O(1)
// startsWith(): O(1)
public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        if (word == null || word.length() == 0) {
            return;
        }
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++) {
            int pos = word.charAt(i) - 'a';
            if (node.children[pos] == null) {
                node.children[pos] = new TrieNode();
                node.children[pos].val = word.charAt(i);
            } else {
                node.children[pos].count++;
            }
            node = node.children[pos];
        }
        node.isEnd = true;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        if (word == null || word.length() == 0) {
            return false;
        }
        TrieNode node = root;
        for (int i = 0; i < word.length(); i++) {
            int pos = word.charAt(i) - 'a';
            if (node.children[pos] != null) {
                node = node.children[pos];
            } else {
                return false;
            }
        }
        return node.isEnd;
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        if (prefix == null || prefix.length() == 0) {
            return false;
        }
        TrieNode node = root;
        for (int i = 0; i < prefix.length(); i++) {
            int pos = prefix.charAt(i) - 'a';
            if (node.children[pos] != null) {
                node = node.children[pos];
            } else {
                return false;
            }
        }
        return true;
    }
}

// Your Trie object will be instantiated and called as such:
// Trie trie = new Trie();
// trie.insert("somestring");
// trie.search("key");
```


## Binary Tree Level Order Traversal

[Problem URL](https://leetcode.com/problems/binary-tree-level-order-traversal/)

Description:
> Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).
> 
> For example:
> Given binary tree [3,9,20,null,null,15,7],
> return its level order traversal as:
> [
>   [3],
>   [9,20],
>   [15,7]
> ]

Solution:
Version 1
```java
// Time O(n)
// Space O(n)
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<List<Integer>>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> queue = new LinkedList<TreeNode>();
    queue.offer(root);
    int level = 0;
    int currLevelNum = 1;
    int nextLevelNum = 0;
    while (!queue.isEmpty()) {
        root = queue.poll();
        if (result.size() == level) {
            result.add(new ArrayList<Integer>());
        }
        result.get(level).add(root.val);
        currLevelNum--;
        if (root.left != null) {
            queue.offer(root.left);
            nextLevelNum++;
        }
        if (root.right != null) {
            queue.offer(root.right);
            nextLevelNum++;
        }
        if (currLevelNum == 0) {
            level++;
            currLevelNum = nextLevelNum;
            nextLevelNum = 0;
        }
        
    }
    return result;
}
```

Version 2
```java
// Time O(n)
// Space O(n)
public List<List<Integer>> levelOrder(TreeNode root) {
    // BFS based
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) {
        return result;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> currLevel = new ArrayList<>();
        // when getting started for each level,
        // the number of nodes in current level is
        // the size of queue since when each level ends
        // all nodes in that level will be polled
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            currLevel.add(node.val);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        result.add(currLevel);
    }
    return result;
}
```


## Random Pick Index

[Problem URL](https://leetcode.com/problems/random-pick-index)

Description:

> Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.
> 
> Note:
> The array size can be very large. Solution that uses too much extra space will not pass the judge.
> 
> Example:
> 
> int[] nums = new int[] {1,2,3,3,3};
> Solution solution = new Solution(nums);
> 
> // pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.
> solution.pick(3);
> 
> // pick(1) should return 0. Since in the array only nums[0] is equal to 1.
> solution.pick(1);

Solution1:
```java
// Time:
// Solution(), O(1)
// pick(), O(n)
// Space:
// Solution(), O(1)
// pick(), O(1)
int[] nums;
Random rand;
public Solution(int[] nums) {
    this.nums = nums;
    rand = new Random();
}

public int pick(int target) {
    int result = -1;
    int count = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != target)
            continue;
        // for example, target is 3, nums = {1,2,3,3,3}
        // index 2 is selected at 1 * (1 / 2) * (2 / 3) = 1 / 3 chance
        // here 1 / 2 comes from the chance that index 3 is not selected
        // 2 / 3 comes from the chance that index 4 is not selected
        // index 3 is selected at (1 / 2) * (2 / 3) chance
        // index 4 is selected at (1 / 3) chance
        if (rand.nextInt(++count) == 0)
            result = i;
    }
    return result;
}
```

Solution2:
```java
// Time:
// Solution(), O(n)
// pick(), O(1)
// Space:
// Solution(), O(n * m), m is average #indices
// pick(), O(1)
Map<Integer, List<Integer>> indices;
public Solution(int[] nums) {
    indices = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        indices.putIfAbsent(nums[i], new ArrayList<>());
        indices.get(nums[i]).add(i);
    }
}

public int pick(int target) {
    List<Integer> candidates = indices.get(target);
    int i = (int)(Math.random() * candidates.size());
    return candidates.get(i);
}
```


## Brick Wall

[Problem URL](https://leetcode.com/problems/brick-wall)

Description:

> There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks.
> 
> The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right.
> 
> If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks.
> 
> You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.
> 
> Example:
> 
> Input: 
> [[1,2,2,1],
>  [3,1,2],
>  [1,3,2],
>  [2,4],
>  [3,1,2],
>  [1,3,1,1]]
> Output: 2
> Explanation: 
> 
> Note:
> 
>     The width sum of bricks in different rows are the same and won't exceed INT_MAX.
>     The number of bricks in each row is in range [1,10,000]. The height of wall is in range [1,10,000]. Total number of bricks of the wall won't exceed 20,000.

Solution:
Time O(n * m), n = wall.size(), m = average #bricks in each row
Space O(l), map contains at most l elements, l is the width of the wall

```java
public int leastBricks(List<List<Integer>> wall) {
    if (wall.size() == 0)
        return 0;
    int count = 0;
    // key is length
    // value is count
    // store to find most common length
    // so to cross minimum bricks
    Map<Integer, Integer> map = new HashMap<>();
    for (List<Integer> row : wall) {
        int length = 0;
        // except the last brick
        for (int i = 0; i < row.size() - 1; i++) {
            length += row.get(i);
            map.put(length, map.getOrDefault(length, 0) + 1);
            count = Math.max(count, map.get(length));
        }
    }
    return wall.size() - count;
}
```


## Longest Continuous Increasing Subsequence

[Problem URL](https://leetcode.com/problems/longest-continuous-increasing-subsequence)

Description:

> Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).
> 
> Example 1:
> Input: [1,3,5,4,7]
> Output: 3
> Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. 
> Even though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. 
> Example 2:
> Input: [2,2,2,2,2]
> Output: 1
> Explanation: The longest continuous increasing subsequence is [2], its length is 1. 
> Note: Length of the array will not exceed 10,000.

Solution:
```java
// Time O(n)
// Space O(1)
public int findLengthOfLCIS(int[] nums) {
    // cnt = current longest length ending with nums[i]
    int res = 0, cnt = 0;
    for (int i = 0; i < nums.length; i++)
        if (i == 0 || nums[i - 1] < nums[i])
            res = Math.max(res, ++cnt);
        else
            cnt = 1;
    return res;
}
```


## Implement Strstr

[Problem URL](https://leetcode.com/problems/implement-strstr)

Description:

> Implement strStr().
> 
> Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
> 
> Example 1:
> 
> Input: haystack = "hello", needle = "ll"
> Output: 2
> Example 2:
> 
> Input: haystack = "aaaaa", needle = "bba"
> Output: -1

Solution:
```java
// Time O(m * n), m, n = len of two inputs
// Space O(1)
public int strStr(String haystack, String needle) {
    if (haystack == null || needle == null)
        return -1;
    if (needle.isEmpty())
        return 0; // edge case: "",""=>0  "a",""=>0
    for (int i = 0; i <= haystack.length() - needle.length(); i++) {
        for (int j = 0; j < needle.length() && haystack.charAt(i + j) == needle.charAt(j); j++)
            if (j == needle.length() - 1)
                return i;
    }
    return -1;
}
```


## Word Ladder

[Problem URL](https://leetcode.com/problems/word-ladder)

Description:

> Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
> 
> Only one letter can be changed at a time.
> Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
> For example,
> 
> Given:
> beginWord = "hit"
> endWord = "cog"
> wordList = ["hot","dot","dog","lot","log","cog"]
> As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
> return its length 5.
> 
> Note:
> Return 0 if there is no such transformation sequence.
> All words have the same length.
> All words contain only lowercase alphabetic characters.
> You may assume no duplicates in the word list.
> You may assume beginWord and endWord are non-empty and are not the same.
> UPDATE (2017/1/20):
> The wordList parameter had been changed to a list of strings (instead of a set of strings). Please reload the code definition to get the latest changes.

Solution:
```java
// Time O(n * m), n = wordList.size(), m = beginWord.length()
// Space O(n)
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    if (beginWord == null || endWord == null || beginWord.length() == 0 || endWord.length() == 0 || beginWord.length() != endWord.length())
        return 0;
    Set<String> wordSet = new HashSet<>(wordList);
    Set<String> visited = new HashSet<>();
    Queue<String> queue = new LinkedList<>();
    // the distance
    int dist = 1;
    // #words to check on curr level and next level
    int currLvlNum = 1, nextLvlNum = 0;
    visited.add(beginWord);
    queue.offer(beginWord);
    while (!queue.isEmpty()) {
        String curr = queue.poll();
        currLvlNum--;
        for (int i = 0; i < curr.length(); i++) {
            char[] chars = curr.toCharArray();
            for (char c = 'a'; c <= 'z'; c++) {
                // replace one letter a time
                chars[i] = c;
                String temp = new String(chars);
                if (endWord.equals(temp))
                    return dist + 1;
                else {
                    if (wordSet.contains(temp) && !visited.contains(temp)) {
                        nextLvlNum++;
                        queue.offer(temp);
                        visited.add(temp);
                    }
                }
            }
        }
        if (currLvlNum == 0) {
            dist++;
            currLvlNum = nextLvlNum;
            nextLvlNum = 0;
        }
    }
    return 0;
}
```

Solution2:
```java
// Time O(n * m), n = wordList.size(), m = beginWord.length()
// Space O(n)
public int ladderLength(String beginWord, String endWord, List<String> wordList) {
    if (beginWord == null || endWord == null || beginWord.length() == 0
        || endWord.length() == 0 || beginWord.length() != endWord.length())
        return 0;
    Set<String> wordSet = new HashSet<>(wordList);
    if (!wordSet.contains(endWord))
        return 0;
    int pathLength = 2;

    Set<String> start = new HashSet<>();
    Set<String> end = new HashSet<>();
    start.add(beginWord);
    end.add(endWord);
    wordSet.remove(beginWord);
    wordSet.remove(endWord);

    while (!start.isEmpty()){
        // switch, always search from smaller set
        // bidirectional search
        if (start.size() > end.size()){
            Set<String> temp = start;
            start = end;
            end = temp;
        }
        Set<String> next = new HashSet<>();
        for (String cur : start){
            char[] strArray = cur.toCharArray();
            for (int i = 0; i < strArray.length;i++){
                char old = strArray[i];
                for (char c = 'a';c <= 'z';c++){
                    strArray[i] = c;
                    String str = String.valueOf(strArray);
                    if (end.contains(str))
                        return pathLength;
                    if (wordSet.contains(str)) {
                        next.add(str);
                        wordSet.remove(str);
                    }
                }
                strArray[i] = old;
            }
        }
        start = next;
        pathLength++;
    }
    return 0;
}
```


## Palindromic Substrings

[Problem URL](https://leetcode.com/problems/palindromic-substrings)

Description:

> Given a string, your task is to count how many palindromic substrings in this string.
> 
> The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
> 
> Example 1:
> Input: "abc"
> Output: 3
> Explanation: Three palindromic strings: "a", "b", "c".
> Example 2:
> Input: "aaa"
> Output: 6
> Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
> Note:
> The input string length won't exceed 1000.

Solution:
```java
// Time O(n ^ 2)
// Space O(1)
public int countSubstrings(String S) {
    int len = S.length(), res = 0;
    // in total 2 * len - 1 centers
    // len at letters, and len - 1 between letters
    for (int center = 0; center <= 2 * len - 1; center++) {
        int left = center / 2;
        // if odd, right = left + 1,
        // if even, right = left
        int right = left + center % 2;
        while (left >= 0 && right < len && S.charAt(left) == S.charAt(right)) {
            res++;
            // expand from center to two directions
            left--;
            right++;
        }
    }
    return res;
}
```


## Alien Dictionary

[Problem URL](https://leetcode.com/problems/alien-dictionary)

Description:

> There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.
> 
> Example 1:
> Given the following words in dictionary,
> 
> [
>   "wrt",
>   "wrf",
>   "er",
>   "ett",
>   "rftt"
> ]
> 
> The correct order is: "wertf".
> 
> Example 2:
> Given the following words in dictionary,
> 
> [
>   "z",
>   "x"
> ]
> 
> The correct order is: "zx".
> 
> Example 3:
> Given the following words in dictionary,
> 
> [
>   "z",
>   "x",
>   "z"
> ]
> 
> The order is invalid, so return "".
> 
> Note:
> 
>     You may assume all letters are in lowercase.
>     You may assume that if a is a prefix of b, then a must appear before b in the given dictionary.
>     If the order is invalid, return an empty string.
>     There may be multiple valid order of letters, return any one of them is fine.


Solution1:
Consider the order of letters as a directed map
a -> b means a comes before b (one letter points the letters come after it)
order is only reflected in orders of different words (letters in the same words are not in order)

Time:
building graph O(n * m), n is words.length (|E|), m is average length of the words (|V|)
topolical sort is O(|V| + |E|), so overral is O(n * m)
Space:
O(|V| + |E|) (inDegree uses O(|V|), adjList use O(|E|)), so (n + m)
```java
public String alienOrder(String[] words) {
    Map<Character, Set<Character>> adjList = new HashMap<>();
    Map<Character, Integer> inDegree = new HashMap<>();
    if (words == null || words.length == 0)
        return "";
    StringBuilder sb = new StringBuilder();
    // initialize the in degrees
    for (String word : words)
        for (char c : word.toCharArray())
            inDegree.put(c, 0);
    // build the graph and set the in degrees
    for (int i = 0; i < words.length - 1; i++) {
        // sorted dictionary , consider only adjacent word
        String curr = words[i];
        String next = words[i + 1];
        // find the first different letter
        int len = Math.min(curr.length(), next.length());
        for (int j = 0; j < len; j++) {
            char c1 = curr.charAt(j);
            char c2 = next.charAt(j);
            // add the edge, update the in degree
            if (c1 != c2) {
                adjList.putIfAbsent(c1, new HashSet<>());
                Set<Character> neighborLetters = adjList.get(c1);
                if (!neighborLetters.contains(c2)) {
                    neighborLetters.add(c2);
                    inDegree.put(c2, inDegree.get(c2) + 1);
                }
                break;
            }
        }
    }
    // do topological sort, here a BFS-based one (Kahn's algorithm)
    Queue<Character> queue = new LinkedList<>();
    // first enqueue all letters with no incoming edges 
    for (char c : inDegree.keySet())
        if (inDegree.get(c) == 0)
            queue.offer(c);
    // dequeue letters and decrement in degrees
    while (!queue.isEmpty()) {
        char curr = queue.poll();
        sb.append(curr);
        if (adjList.containsKey(curr)) {
            for (char next : adjList.get(curr)) {
                inDegree.put(next, inDegree.get(next) - 1);
                // enqueue when no incoming edges remained
                if (inDegree.get(next) == 0)
                    queue.offer(next);
            }
        }
    }
    // if the order is valid, then all letters shoud be in the StringBuilder
    // otherwise it is invalid
    return sb.length() == inDegree.size() ? sb.toString() : "";
}
```


Solution2:
```java
// Time:
// build graph O(n * m), n is words.length, m is average length of words
// dfs topological sort is O(|V| + |E|) = O(n + m), so overral O(n * m)
// Space:
// adjMat is N ^ 2 = O(1), visited is O(1), dfs goes to |V| depth,
// so overral O(n)
// visited[i] = -1, initialization
// visited[i] = 0, unvisited
// visited[i] = 1, visiting
// visited[i] = 2, visited
int N = 26;
public String alienOrder(String[] words) {
    boolean[][] adjMat = new boolean[N][N];
    int[] visited = new int[N];
    // build the graph
    Arrays.fill(visited, -1);
    for (int i = 0; i < words.length; i++) {
        for (char c : words[i].toCharArray())
            visited[c - 'a'] = 0;
        if (i > 0) {
            String prev = words[i - 1];
            String curr = words[i];
            // find the first different letter
            int len = Math.min(prev.length(), curr.length());
            for (int j = 0; j < len; j++) {
                char c1 = prev.charAt(j);
                char c2 = curr.charAt(j);
                if (c1 != c2) {
                    // add en edge
                    adjMat[c1 - 'a'][c2 - 'a'] = true;
                    break;
                }
            }
        }
    }
    // do dfs
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i < N; i++)
        if (visited[i] == 0) // not visited
            if (!dfs(sb, visited, adjMat, i))
                return "";
    return sb.reverse().toString();
}

// return false if cycle detected
private boolean dfs(StringBuilder sb, int[] visited, boolean[][] adjMat, int i) {
    // mark visiting
    visited[i] = 1;
    for (int j = 0; j < N; j++) {
        if (adjMat[i][j]) {
            // cycle detected
            if (visited[j] == 1)
                return false;
            if (visited[j] == 0)
                if (!dfs(sb, visited, adjMat, j))
                    return false;
        }
    }
    // mark visited
    visited[i] = 2;
    sb.append((char)(i + 'a'));
    return true;
}
```


## Best Time To Buy And Sell Stock With Transaction Fee

[Problem URL](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)

Description:

> Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.
> 
> You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)
> 
> Return the maximum profit you can make.
> 
> Example 1:
> Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
> Output: 8
> Explanation: The maximum profit can be achieved by:
> Buying at prices[0] = 1
> Selling at prices[3] = 8
> Buying at prices[4] = 4
> Selling at prices[5] = 9
> The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
> Note:
> 
> 0 < prices.length <= 50000.
> 0 < prices[i] < 50000.
> 0 <= fee < 50000.


Solution:
```java
// Time O(n)
// Space O(1)
public int maxProfit(int[] prices, int fee) {
    // two states: hold stock at prices[i] or not
    // sell = current cash have (after sell)
    // buy = after buy
    int sell = 0, buy = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        sell = Math.max(sell, buy + prices[i] - fee);
        buy = Math.max(buy, sell - prices[i]);
    }
    return sell;
}
```


## Increasing Triplet Subsequence

[Problem URL](https://leetcode.com/problems/increasing-triplet-subsequence)

Description:

> Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.
> 
> Formally the function should:
> Return true if there exists i, j, k 
> such that arr[i] < arr[j] < arr[k] given 0 â‰¤ i < j < k â‰¤ n-1 else return false.
> Your algorithm should run in O(n) time complexity and O(1) space complexity.
> 
> Examples:
> Given [1, 2, 3, 4, 5],
> return true.
> 
> Given [5, 4, 3, 2, 1],
> return false.


Solution:
```java
// Time O(n)
// Space O(1)
public boolean increasingTriplet(int[] nums) {
    int min = Integer.MAX_VALUE, secondMin = Integer.MAX_VALUE;
    for (int n: nums) {
        // <= for dups, [1, 1, 1, 1]
        if (n <= min)
            min = n;
        else if (n <= secondMin)
            secondMin = n;
        else
            return true;
    }
    return false;
}
```


## Populating Next Right Pointers in Each Node

[Problem URL](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)

Description:

> Given a binary tree
> 
> public class TreeLinkNode {
>     int val;
>     TreeLinkNode left, right, next;
>     TreeLinkNode(int x) { val = x; }
> }
> 
> Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
> 
> Initially, all next pointers are set to NULL.
> 
> Note:
> 
> You may only use constant extra space.
> You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).


Solution:
Based on level order traversal

```java
// Time O(n)
// Space O(1)
public void connect(TreeLinkNode root) {
    if (root == null) {
        return;
    }
    TreeLinkNode prev = root;
    TreeLinkNode curr = null;
    while (prev.left != null) {
        curr = prev;
        while (curr != null) {
            curr.left.next = curr.right;
            if (curr.next != null) {
                curr.right.next = curr.next.left;
            }
            curr = curr.next;
        }
        prev = prev.left;
    }
}
```


## Populating Next Right Pointers in Each Node II

[Problem URL](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/)

Description:

> Follow up for problem "Populating Next Right Pointers in Each Node".
> 
> What if the given tree could be any binary tree? Would your previous solution still work?
> 
> Note:
> 
> You may only use constant extra space.

Solution:
Leaves may not be on the same level or right next to each other

```java
// Time O(n)
// Space O(1)
public void connect(TreeLinkNode root) {
    if (root == null) {
        return;
    }
    // the current visiting node
    TreeLinkNode curr = root;
    // the previously visited node on next level
    TreeLinkNode prev = null;
    // the head node on next level
    TreeLinkNode head = null;
    
    // moving down each level
    while (curr != null) {
        // moving right in the current level
        while (curr != null) {
            // left child
            if (curr.left != null) {
                if (prev != null) {
                    prev.next = curr.left;
                } else {
                    head = curr.left;
                }
                prev = curr.left;
            }
            // right chlid
            if (curr.right != null) {
                if (prev != null) {
                    prev.next = curr.right;
                } else {
                    head = curr.right;
                }
                prev = curr.right;
            }
            // move to next node on the same level
            curr = curr.next;
        }
        // move to next level
        curr = head;
        prev = null;
        head = null;
    }
}
```



## Sqrt x

[Problem URL](https://leetcode.com/problems/sqrtx/)

Description:

> Implement int sqrt(int x).
> 
> Compute and return the square root of x.

Solution:
// Time O(logx)
// Space O(1)
```java
public int mySqrt(int x) {
    if (x < 0) {
        return -1;
    }
    if (x == 0) {
        return 0;
    }
    int l = 1, r = x / 2 + 1;
    while (l <= r) {
        int m = (l + r) / 2;
        if (m <= x / m && (m + 1) > x / (m + 1)) {
            return m;
        } else if (m > x / m) {
            r = m - 1;
        } else {
            l = m + 1;
        }
    }
    return 0;
}
```


## Hamming Distance

[Problem URL](https://leetcode.com/problems/hamming-distance)

Description:

> The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
> 
> Given two integers x and y, calculate the Hamming distance.
> 
> Note:
> 0 â‰¤ x, y < 231.
> 
> Example:
> 
> Input: x = 1, y = 4
> 
> Output: 2
> 
> Explanation:
> 1   (0 0 0 1)
> 4   (0 1 0 0)
>        â†‘   â†‘
> 
> The above arrows point to positions where the corresponding bits are different.


Solution:
Time O(1)
Space O(1)
```java
public int hammingDistance(int x, int y) {
    int res = 0;
    for (int i = 0; i < 32; i++)
        res += ((x >> i & 1) ^ (y >> i & 1));
    return res;
}
```


## Powx N

[Problem URL](https://leetcode.com/problems/powx-n)

Description:

> Implement pow(x, n).
> 
> 
> Example 1:
> 
> Input: 2.00000, 10
> Output: 1024.00000
> Example 2:
> 
> Input: 2.10000, 3
> Output: 9.26100

Solution:
```java
// Time O(logn)
// Space O(1)
public double myPow(double x, int n) {
    double res = 1;
    long absVal = Math.abs((long)n);
    while(absVal > 0) {
        if ((absVal % 2) == 1)
            res *= x;
        absVal /= 2;
        x *= x;
    }
    return n < 0 ? 1 / res : res;
}
```


## Split Array Largest Sum

[Problem URL](https://leetcode.com/problems/split-array-largest-sum/)

Description:

> Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
> 
> Note:
> If n is the length of array, assume the following constraints are satisfied:
> 
> 1 â‰¤ n â‰¤ 1000
> 1 â‰¤ m â‰¤ min(50, n)
> 
> 
> Examples:
> 
> Input:
> nums = [7,2,5,10,8]
> m = 2
> 
> Output:
> 18
> 
> Explanation:
> There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8],
> where the largest sum among the two subarrays is only 18. 


Solution:
```java
// Time O(nlog(sum array))
// Space O(1)
public int splitArray(int[] nums, int m) {
    int max = 0;
    long sum = 0;
    for (int num: nums) {
        max = Math.max(num, max);
        sum += num;
    }
    // The answer is between maximum value of input array numbers and sum of those numbers.
    // Use binary search to approach the correct answer.
    return (int)binarySearch(nums, m, max, sum);
}

private long binarySearch(int[] nums, int m, long l, long r) {
    /*
    Use greedy to narrow down left and right boundaries in binary search.
    1 Cut the array from left.
    2 Try our best to make sure that the sum of numbers between
    each two cuts (inclusive) is large enough but still less than mid.
    3 Weâ€™ll end up with two results: either we can divide the array
    into more than m subarrays or we cannot.
    
    If we can, it means that the mid value we pick is too small because
    weâ€™ve already tried our best to make sure each part holds as
    many non-negative numbers as we can but we still have numbers left.
    So, it is impossible to cut the array into m parts and make sure
    each parts is no larger than mid. We should increase m.
    This leads to l = mid + 1;
    
    If we canâ€™t, it is either we successfully divide the array
    into m parts and the sum of each part is less than mid,
    or we used up all numbers before we reach m.
    Both of them mean that we should lower mid because we need to find the minimum one.
    This leads to r = mid - 1;
    */
    while (l < r) {
        long mid = l + (r - l) / 2;
        // narrow down the summation limit
        // if possible, then narror further down to minimize the summation
        if (valid(nums, m, mid)) {
            r = mid;
        } else {
            // otherwise, the current limit is too small
            // increase it
            l = mid + 1;
        }
    }
    return l;
}

// whether the array can be cut into m subarrays
// with each summation not exceeding the limit
private boolean valid(int[] nums, int m, long limit) {
    int count = 1, currSum = 0;
    // make sure it is continuous subarray
    for (int num: nums) {
        currSum += num;
        // For each element num, if sum + num <= x,
        // it means we can add num to the current subarray without exceeding the limit.
        // Otherwise, we need to make a cut here,
        // start a new subarray with the current element num.
        // This leads to an increment in the number of subarrays.
        if (currSum > limit) {
            currSum = num;
            count++;
            if (count > m)
                return false;
        }
    }
    return true;
}
```


## Maximal Rectangle

[Problem URL](https://leetcode.com/problems/maximal-rectangle)

Description:

> Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.
> 
> For example, given the following matrix:
> 
> 1 0 1 0 0
> 1 0 1 1 1
> 1 1 1 1 1
> 1 0 0 1 0
> Return 6.


Solution1:
```java
// Time O(m * n), m, n are dims of matrix
// Space O(n)
public int maximalRectangle(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return 0;
    int m = matrix.length, n = matrix[0].length;
    // height[i] = max height of 1s in column j
    int[] height = new int[n];
    // left[i] = left means at current position,
    // what is the index of left bound of the rectangle with height[j].
    // 0 means at this position, no rectangle
    int[] left = new int[n];
    // right[j] = means the right bound index of this rectangle.
    // n means no rectangle.
    int[] right = new int[n];
    for (int j = 0; j < n; j++)
        right[j] = n;
    int maxArea = 0;
    for (int i = 0; i < m; i++) {
        int currLeft = 0, currRight = n;
        for (int j = 0; j < n; j++)
            if (matrix[i][j] == '1')
                height[j]++;
            else
                height[j] = 0;
        for (int j = 0; j < n; j++)
            if (matrix[i][j] == '1')
                left[j] = Math.max(left[j], currLeft);
            else {
                left[j] = 0;
                currLeft = j + 1;
            }
        for (int j = n - 1; j >= 0; j--)
            if (matrix[i][j] == '1')
                right[j] = Math.min(right[j], currRight);
            else {
                right[j] = n;
                currRight = j;
            }
        for (int j = 0; j < n; j++) {
            maxArea = Math.max(maxArea, (right[j] - left[j]) * height[j]);
        }
    }
    return maxArea;
}
```

Solution2:
Use stack, similar method as Largest Rectangle in Histogram
```java
// Time O(m * n), in the inner loop, each column index is pushed and poped once
// Space O(n)
public int maximalRectangle(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return 0;
    int m = matrix.length, n = matrix[0].length;
    // heights[j] = max heights of 1s at column j
    int[] heights = new int[n + 1];
    heights[n] = 0;
    int res = 0;
    for (int i = 0; i < m; i++) {
        Stack<Integer> stack = new Stack<>();
        for (int j = 0; j <= n; j++) {
            if (j < n) {
                // increment by 1 or reset to 0
                if (matrix[i][j] == '1')
                    heights[j] += 1;
                else
                    heights[j] = 0;
            }
            if (stack.isEmpty() || heights[j] >= heights[stack.peek()])
                // push the index if met a higher bar
                stack.push(j);
            else {
                while (!stack.isEmpty() && heights[j] < heights[stack.peek()]) {
                    // current area = max height bar (height[top]) * width (distance between highest and 2nd highest)
                    int currArea = heights[stack.pop()] * (stack.isEmpty() ? j : j - stack.peek() - 1);
                    res = Math.max(currArea, res);
                }
                stack.push(j);
            }
        }
    }
    return res;
}
```


## Text Justification

[Problem URL](https://leetcode.com/problems/text-justification)

Description:

> Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.
> 
> You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly L characters.
> 
> Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.
> 
> For the last line of text, it should be left justified and no extra space is inserted between words.
> 
> For example,
> words: ["This", "is", "an", "example", "of", "text", "justification."]
> L: 16.
> 
> Return the formatted lines as:
> [
>    "This    is    an",
>    "example  of text",
>    "justification.  "
> ]
> Note: Each word is guaranteed not to exceed L in length.


Solution:
```java
// Time O(n), n = words.length
// Space O(maxWidth * m), m is number of rows in the results
public List<String> fullJustify(String[] words, int maxWidth) {
    List<String> res = new ArrayList<>();
    if (words == null || words.length == 0 || maxWidth <= 0) {
        res.add("");
        return res;
    }
    // i, j are both indices for words
    // i is the start, j is the index for the last word on the line
    for (int i = 0, j; i < words.length; i = j) {
        // each word has at least one space after it, except the last one
        // so initialize len as -1
        int len = -1;
        for (j = i; j < words.length && len + words[j].length() + 1 <= maxWidth; j++)
            len += words[j].length() + 1;
        StringBuilder sb = new StringBuilder(words[i]);
        int distributedSpace = 1, extraSpace = 0;
        // compute spaces only if the last word is the word after the start one (words[i])
        // or the last word in the array
        if (j != i + 1 && j != words.length) {
            // here j is already pointing the next word
            // j - i - 1 = #gaps
            // +1 for default space after each words
            int gaps = (j - i - 1);
            distributedSpace = (maxWidth - len) / gaps + 1;
            extraSpace = (maxWidth - len) % gaps;
        }
        // if not the two above special cases
        // append the words and spaces
        for (int l = i + 1; l < j; l++) {
            for (int s = 0; s < distributedSpace; s++)
                sb.append(" ");
            if (extraSpace-- > 0)
                sb.append(" ");
            sb.append(words[l]);
        }
        // handle special cases
        // only one word at current line, or reached the last word
        // then fill the rest with spaces
        int rest = maxWidth - sb.length();
        while (rest-- > 0)
            sb.append(" ");
        res.add(sb.toString());
    }
    return res;
}
```


## Course Schedule II

[Problem URL](https://leetcode.com/problems/course-schedule-ii)

Description:

> There are a total of n courses you have to take, labeled from 0 to n - 1.
> 
> Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
> 
> Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.
> 
> There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.
> 
> For example:
> 
> 2, [[1,0]]
> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]
> 
> 4, [[1,0],[2,0],[3,1],[3,2]]
> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is[0,2,1,3].
> 
> Note:
> The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
> You may assume that there are no duplicate edges in the input prerequisites.

```java
// Time O(|V| + |E|)
// Space O(|V| + |E|), |V| = numCourses, |E| = prerequisites.length
public int[] findOrder(int numCourses, int[][] prerequisites) {
    int[] status = new int[numCourses];
    List<List<Integer>> graph = new ArrayList<>();
    List<Integer> orders = new ArrayList<>();
    for (int i = 0; i < numCourses; i++) {
        graph.add(new ArrayList<>());
    }
    // build the graph
    for (int i = 0; i < prerequisites.length; i++) {
        graph.get(prerequisites[i][0]).add(prerequisites[i][1]);
    }
    // dfs
    for (int i = 0; i < numCourses; i++) {
        if (!visit(orders, graph, status, i)) {
            return new int[0];
        }
    }
    int[] result = new int[numCourses];
    for (int i = 0; i < numCourses; i++) {
        result[i] = orders.get(i);
    }
    return result;
}

private boolean visit(List<Integer> orders, List<List<Integer>> graph, int[] status, int node) {
    // return if valid (cycle makes it invalid)
    if (status[node] == 2) {
        return true;
    }
    // cycle detected
    if (status[node] == 1) {
        return false;
    }
    status[node] = 1;
    for (int connectedNode: graph.get(node)) {
        if (!visit(list, graph, status, connectedNode)) {
            return false;
        }
    }
    status[node] = 2;
    list.add(node);
    return true;
}
```


## Maximal Square

[Problem URL](https://leetcode.com/problems/maximal-square/)

Description:

> Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.
> 
> For example, given the following matrix:
> 
> 1 0 1 0 0
> 1 0 1 1 1
> 1 1 1 1 1
> 1 0 0 1 0
> 
> Return 4.

Solution:
Maintain a 2D-array to store the max size of square of corresponding cell in the original matrix.

Sub-problem: given the size of surrounding cells, get the size of current cell

Solution1
```java
// Time O(m * n)
// Space O(m * n)
public int maximalSquare(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return 0;
    int m = matrix.length, n = matrix[0].length;
    // side[i][j] represents max side of square regarding cell matrix[i - 1][j - 1]
    int[][] side = new int[m + 1][n + 1];
    int maxSide = 0;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (matrix[i - 1][j - 1] == '1') {
                side[i][j] = Math.min(side[i - 1][j - 1], Math.min(side[i - 1][j], side[i][j - 1])) + 1;
                maxSide = Math.max(side[i][j], maxSide);
            }
    return maxSide * maxSide;
}
```


Solution2:
```java
// Time O(m * n)
// Space O(n)
public int maximalSquare(char[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return 0;
    int m = matrix.length, n = matrix[0].length;
    int[] side = new int[n + 1];
    int maxSide = 0, prev = 0;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            int temp = side[j];
            if (matrix[i - 1][j - 1] == '1') {
                side[j] = Math.min(Math.min(side[j - 1], prev), side[j]) + 1;
                maxSide = Math.max(maxSide, side[j]);
            } else {
                side[j] = 0;
            }
            prev = temp;
        }
    }
    return maxSide * maxSide;
}
```


## H Index

[Problem URL](https://leetcode.com/problems/h-index)

Description:

> Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.
> 
> According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N âˆ’ h papers have no more than h citations each."
> 
> For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.
> 
> Note: If there are several possible values for h, the maximum one is taken as the h-index.

Solution1:
```java
// Time O(nlogn)
// Space O(1)
public int hIndex(int[] citations) {
    // sorting the citations in ascending order
    Arrays.sort(citations);
    // finding h-index by linear search
    // based on definition, max possible h index is n
    int i = 0, n = citations.length;
    while (i < n && citations[n - 1 - i] > i)
        i++;
    return i; // after the while loop, i = i' + 1
}
```

Solution2:
```java
// Time O(n)
// Space O(n)
public int hIndex(int[] citations) {
    int n = citations.length;
    // hidxCnt[i] = cnt for #papers with citation number i
    int[] hidxCnt = new int[n + 1];
    // max possible h index is n
    // counting papers for each possible h index
    for (int c: citations)
        hidxCnt[Math.min(n, c)]++;
    // finding the h-index
    int h = n;
    for (int sum = hidxCnt[n]; h > sum; sum += hidxCnt[h])
        h--;
    return h;
}
```


## Palindrome Linked List

[Problem URL](https://leetcode.com/problems/palindrome-linked-list)

Description:

> Given a singly linked list, determine if it is a palindrome.
> 
> Follow up:
> Could you do it in O(n) time and O(1) space?

Solution:
Time O(n), space O(1)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null)
        return true;
    ListNode fast = head, slow = head;
    // make slow at the middle
    // don't matter if the length is odd or even
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    // reverse right half
    // if palindrome, left half and right half should be the same
    slow = reverse(slow);
    fast = head;
    while (fast != null && slow != null) {
        if (fast.val != slow.val)
            return false;
        fast = fast.next;
        slow = slow.next;
    }
    return true;
}

private ListNode reverse(ListNode head) {
    ListNode prev = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
    }
    return prev;
}
```


## Sum Of Left Leaves

[Problem URL](https://leetcode.com/problems/sum-of-left-leaves)

Description:

> Find the sum of all left leaves in a given binary tree.
> 
> Example:
> 
>     3
>    / \
>   9  20
>     /  \
>    15   7
> 
> There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.


Solution1:
```java
// Time O(n)
// Space O(h), worst case h = n
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null)
        return 0;
    int res = 0;
    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.push(root);
    while (!stack.empty()) {
        TreeNode node = stack.pop();
        if (node.left != null) {
            if (node.left.left == null && node.left.right == null)
                res += node.left.val;
            else
                stack.push(node.left);
        }
        if (node.right != null) {
            if (node.right.left != null || node.right.right != null)
                stack.push(node.right);
        }
    }
    return res;
}
```

Solution2:
```java
// Time O(n)
// Space O(h), worst case h = n
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null)
        return 0;
    int sum = sumOfLeftLeaves(root.right);
    if (root.left != null) {
        if (root.left.left == null && root.left.right == null)
            sum += root.left.val;
        else
            sum += sumOfLeftLeaves(root.left);
    }
    return sum;
}
```


## Reverse Nodes In K Group

[Problem URL](https://leetcode.com/problems/reverse-nodes-in-k-group)

Description:

> Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
> 
> k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
> 
> You may not alter the values in the nodes, only nodes itself may be changed.
> 
> Only constant memory is allowed.
> 
> For example,
> Given this linked list: 1->2->3->4->5
> 
> For k = 2, you should return: 2->1->4->3->5
> 
> For k = 3, you should return: 3->2->1->4->5


Solution:
Time O(n)
Space O(1)
```java
public ListNode reverseKGroup(ListNode head, int k) {
    if (head == null || k == 0)
        return head;
    // get the length of the list
    int len = 0;
    ListNode node = head;
    while (node != null) {
        node = node.next;
        len++;
    }
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode prev = dummy, tail = head;
    while (len >= k) {
        for (int i = 1; i < k; i++) {
            // constantly swaping nodes to be prev.next
            ListNode next = tail.next.next;
            // reverse pointing
            tail.next.next = prev.next;
            // update new prev.next
            prev.next = tail.next;
            // points to new next
            tail.next = next;
        }
        prev = tail;
        tail = tail.next;
        len -= k;
    }
    return dummy.next;
}
```


## Average Of Levels In Binary Tree

[Problem URL](https://leetcode.com/problems/average-of-levels-in-binary-tree)

Description:

> Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.
> 
> Example 1:
> 
> Input:
>     3
>    / \
>   9  20
>     /  \
>    15   7
> Output: [3, 14.5, 11]
> Explanation:
> The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].
> 
> Note:
> 
>     The range of node's value is in the range of 32-bit signed integer.
> 

Solution1:
DFS
Time O(n)
Space O(h)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public List<Double> averageOfLevels(TreeNode root) {
    List<Integer> count = new ArrayList<>();
    List<Double> res = new ArrayList<>();
    average(count, res, 0, root);
    for (int i = 0; i < count.size(); i++)
        res.set(i, res.get(i) / count.get(i));
    return res;
}

private void average(List<Integer> count, List<Double> sum, int level, TreeNode root) {
    if (root == null)
        return;
    if (level < sum.size()) {
        sum.set(level, sum.get(level) + root.val);
        count.set(level, count.get(level) + 1);
    } else {
        sum.add(1.0 * root.val);
        count.add(1);
    }
    average(count, sum, level + 1, root.left);
    average(count, sum, level + 1, root.right);
}
```


Solution2:
Time: O(n)
Space: O(m), m is max #nodes on one level
```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> res = new ArrayList<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        double sum = 0.0;
        int n = queue.size();
        for (int i = 0; i < n; i++) {
            TreeNode curr = queue.poll();
            sum += curr.val;
            if (curr.left != null)
                queue.offer(curr.left);
            if (curr.right != null)
                queue.offer(curr.right);
        }
        res.add(sum / n);
    }
    return res;
}
```


## Two Sum Iv Input Is A Bst

[Problem URL](https://leetcode.com/problems/two-sum-iv-input-is-a-bst)

Description:
> Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.
> 
> Example 1:
> 
> Input: 
>     5
>    / \
>   3   6
>  / \   \
> 2   4   7
> 
> Target = 9
> 
> Output: True
> 
> Example 2:
> 
> Input: 
>     5
>    / \
>   3   6
>  / \   \
> 2   4   7
> 
> Target = 28
> 
> Output: False


Time O(n), worst case traverse entire tree
Space O(h), h is height (best case logn, worse case n)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public boolean findTarget(TreeNode root, int k) {
    Stack<TreeNode> leftStack = new Stack<>();
    Stack<TreeNode> rightStack = new Stack<>();
    // push
    for (TreeNode curr = root; curr != null; curr = curr.left)
        leftStack.push(curr);
    for (TreeNode curr = root; curr != null; curr = curr.right)
        rightStack.push(curr);
    while (!leftStack.isEmpty() && !rightStack.isEmpty() && leftStack.peek() != rightStack.peek()) {
        int currSum = leftStack.peek().val + rightStack.peek().val;
        if (currSum == k)
            return true;
        if (currSum < k)
            for (TreeNode curr = leftStack.pop().right; curr != null; curr = curr.left)
                leftStack.push(curr);
        else
            for (TreeNode curr = rightStack.pop().left; curr != null ; curr = curr.right)
                rightStack.push(curr);
    }
    return false;
}
```


Solution2
```java
// Time O(n)
// Space O(n)
public boolean findTarget(TreeNode root, int k) {
    Set<Integer> set = new HashSet<>();
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        if (queue.peek() != null) {
            TreeNode curr = queue.poll();
            if (set.contains(k - curr.val))
                return true;
            set.add(curr.val);
            queue.offer(curr.left);
            queue.offer(curr.right);
        } else {
            queue.poll();
        }
    }
    return false;
}
```


## Paint House II

[Problem URL](https://leetcode.com/problems/paint-house-ii/)

Description:

> There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.
> 
> The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses.
> 
> Note:
> All costs are positive integers.
> 
> Follow up:
> Could you solve it in O(nk) runtime?

Solution1:
Time O(nkk), space O(nk)
```java
public int minCostII(int[][] costs) {
    if (costs == null || costs.length == 0 || costs[0].length == 0)
        return 0;
    int n = costs.length, k = costs[0].length;
    // dp[i][j] = min cost for painting houses 0..i with color j
    int[][] dp = new int[n][k];
    // initialization
    for (int i = 0; i < k; i++)
        dp[0][i] = costs[0][i];
    for (int i = 1; i < n; i++)
        for (int j = 0; j < k; j++) {
            dp[i][j] = Integer.MAX_VALUE;
            for (int l = 0; l < k; l++) {
                // paint with different color
                if (l == j)
                    continue;
                dp[i][j] = Math.min(dp[i - 1][l] + costs[i][j], dp[i][j]);
            }
        }
    int res = Integer.MAX_VALUE;
    for (int i = 0; i < k; i++)
        res = Math.min(res, dp[n - 1][i]);
    return res;
}
```


Solution2:
```java
// Time O(n * k)
// Space O(n)
public int minCostII(int[][] costs) {
    if (costs == null || costs.length == 0)
        return 0;
    int n = costs.length, k = costs[0].length;
    // min1 = min costs so far
    // min2 = 2nd min costs so far
    // minIndex = index of color with min cost (last used color)
    int min1 = 0, min2 = 0, minIndex = -1;
    // dp[i] = current min cost using color index j
    int[] dp = new int[k];
    for (int i = 0; i < n; i++) {
        int currMin1 = Integer.MAX_VALUE, currMin2 = Integer.MAX_VALUE, currMinIndex = -1;
        for (int j = 0; j < k; j++) {
            dp[j] = (j == minIndex ? min2 : min1) + costs[i][j];
            if (dp[j] < currMin1) {
                currMin2 = currMin1;
                currMin1 = dp[j];
                currMinIndex = j;
            }
            else {
                currMin2 = Math.min(currMin2, dp[j]);
            }
        }
        min1 = currMin1;
        min2 = currMin2;
        minIndex = currMinIndex;
    }
    return min1;
}
```


Solution3:
Time O(nk), space O(1)
```java
public int minCostII(int[][] costs) {
    if (costs == null || costs.length == 0)
        return 0;
    int n = costs.length, k = costs[0].length;
    // min1 = min costs so far
    // min2 = 2nd min costs so far
    // minIndex = index of color with min cost (last used color)
    int min1 = 0, min2 = 0, minIndex = -1;
    for (int i = 0; i < n; i++) {
        int currMin1 = Integer.MAX_VALUE, currMin2 = Integer.MAX_VALUE, currMinIndex = -1;
        for (int j = 0; j < k; j++) {
            int cost = costs[i][j] + (j == minIndex ? min2 : min1);
            if (cost < currMin1) {
                currMin2 = currMin1;
                currMin1 = cost;
                currMinIndex = j;
            } else if (cost < currMin2) {
                currMin2 = cost;
            }
        }
        min1 = currMin1;
        min2 = currMin2;
        minIndex = currMinIndex;
    }
    return min1;
}
```


## Encode And Decode Tinyurl

[Problem URL](https://leetcode.com/problems/encode-and-decode-tinyurl)

Description:

> TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.
> 
> Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.

Solution:
```java
public class Codec {
    // Time O(1), String.hashCode() should be O(1), replace may be O(l), host.length() is constant
    // space O(1) ?
    Map<Integer, String> map = new HashMap<>();
    String host = "http://tinyurl.com/";
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        int hashCode = longUrl.hashCode();
        map.put(hashCode, longUrl);
        return host + hashCode;
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        return map.get(Integer.parseInt(shortUrl.replace(host, "")));
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));
```


## Number of Longest Increasing Subsequence

[Problem URL](https://leetcode.com/problems/number-of-longest-increasing-subsequence/)

Description:

> Given an unsorted array of integers, find the number of longest increasing subsequence.
> 
> Example 1:
> Input: [1,3,5,4,7]
> Output: 2
> Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].
> Example 2:
> Input: [2,2,2,2,2]
> Output: 5
> Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.
> Note: Length of the given array will be not exceed 2000 and the answer is guaranteed to be fit in 32-bit signed int.


Solution:
There are multiple requirements for the result, maintain separate arrays for them.
Time O(n ^ 2), space O(n)
```java
public int findNumberOfLIS(int[] nums) {
    if (nums == null)
        return 0;
    int n = nums.length;
    if (n <= 1)
        return n;
    // count[i] = #longest-seq ending at nums[i]
    int[] count = new int[n];
    // length[i] = length of lonest-seq ending at nums[i]
    int[] length = new int[n];
    // initialization, every num itself is a seq
    Arrays.fill(count, 1);
    int res = 0, longest = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++)
            if (nums[j] < nums[i]) {
                // append nums[i] to seq ending at nums[j]
                if (length[j] >= length[i]) {
                    // new seq longer than previously stored in length[i]
                    // increase length by 1 (comparing to ending at nums[j])
                    // count is the same as count[i]
                    length[i] = length[j] + 1;
                    count[i] = count[j];
                } else if (length[j] + 1 == length[i]) {
                    // newly found seq (by appending nums[i] after nums[j]) is of the same length
                    // as previously stored, add additional count[j] seqs
                    count[i] += count[j];
                }
            }
        if (longest == length[i])
            res += count[i];
        else if (longest < length[i]) {
            longest = length[i];
            res = count[i];
        }
    }
    return res;
}
```


## Contiguous Array

[Problem URL](https://leetcode.com/problems/contiguous-array)

Description:

> Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.
> 
> Example 1:
> Input: [0,1]
> Output: 2
> Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.
> Example 2:
> Input: [0,1,0]
> Output: 2
> Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
> Note: The length of the given binary array will not exceed 50,000.

Solution:
```java
// Time O(n)
// Space O(n)
public int findMaxLength(int[] nums) {
    // key: summation
    // value: last index to get that summation
    Map<Integer, Integer> sumToIndex = new HashMap<>();
    // starts at -1, example, [0, 1], returns 2
    sumToIndex.put(0, -1);
    int sum = 0, maxLen = 0;
    for (int i = 0; i < nums.length; i++) {
        sum += (nums[i] == 1 ? 1 : -1);
        // same summation means the numbers of 1 and 0 are same
        if (sumToIndex.containsKey(sum))
            // no +1 because we only count length of subarray with equal
            // #1s and #0s
            maxLen = Math.max(maxLen, i - sumToIndex.get(sum));
        else
            sumToIndex.put(sum, i);
    }
    return maxLen;
}
```


## Graph Valid Tree

[Problem URL](https://leetcode.com/problems/graph-valid-tree/)

Description:

> Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.
> 
> For example:
> 
> Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.
> 
> Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
> 
> Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.


Solution:
Classic union-find, time O(n + mlogn)(m is |E| = edges.length), space O(n)(?)
```java
public boolean validTree(int n, int[][] edges) {
    int[] nums = new int[n];
    // init roots
    Arrays.fill(nums, -1);
    for (int[] edge : edges) {
        int r1 = find(nums, edge[0]);
        int r2 = find(nums, edge[1]);
        if (r1 == r2)
            return false;
        nums[r1] = r2;
    }
    return edges.length == n - 1;
}

private int find(int[] nums, int v) {
    if (nums[v] == -1)
        return v;
    return find(nums, nums[v]);
}
```


Solution2:
Time (m + n) (m = |V|, n = |E|), space O(m)
```java
public boolean validTree(int n, int[][] edges) {
    List<Integer>[] adjList = new List[n];
    for (int i = 0; i < n; i++)
        adjList[i] = new ArrayList<>();
    for (int[] edge : edges) {
        adjList[edge[0]].add(edge[1]);
        adjList[edge[1]].add(edge[0]);
    }
    Set<Integer> visited = new HashSet<>();
    // check for cycle
    if (hasCycle(adjList, visited, 0, -1))
        return false;
    // the traversal for a valid tree should visit all nodes
    if (visited.size() != n)
        return false;
    return true;
}

private boolean hasCycle(List<Integer>[] adjList, Set<Integer> visited, int v, int pre) {
    visited.add(v);
    for (int u : adjList[v])
        if ((visited.contains(u) && pre != u) || (!visited.contains(u) && hasCycle(adjList, visited, u, v)))
            return true;
    return false;
}
```

Solution3:
Time (m + n) (m = |V|, n = |E|), space O(m)
```java
public boolean validTree(int n, int[][] edges) {
    Map<Integer, Set<Integer>> graph = new HashMap<>();
    for (int i = 0; i < n; i++)
        graph.put(i, new HashSet<Integer>());
    for (int[] edge : edges) {
        graph.get(edge[0]).add(edge[1]);
        graph.get(edge[1]).add(edge[0]);
    }
    Queue<Integer> q = new LinkedList<>();
    Set<Integer> visited = new HashSet<>();
    q.offer(0);
    while (!q.isEmpty()) {
        int v = q.poll();
        if (visited.contains(v))
            return false;
        visited.add(v);
        for (int u : graph.get(v)) {
            q.offer(u);
            graph.get(u).remove(v);
        }
    }
    if (visited.size() != n)
        return false;
    return true;
}
```


## Number Of Corner Rectangles

[Problem URL](https://leetcode.com/problems/number-of-corner-rectangles)

Description:

> Given a grid where each entry is only 0 or 1, find the number of corner rectangles.
> 
> A corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.
> 
>  
> 
> Example 1:
> 
> Input: grid = 
> [[1, 0, 0, 1, 0],
>  [0, 0, 1, 0, 1],
>  [0, 0, 0, 1, 0],
>  [1, 0, 1, 0, 1]]
> Output: 1
> Explanation: There is only one corner rectangle, with corners grid[1][2], grid[1][4], grid[3][2], grid[3][4].
>  
> 
> Example 2:
> 
> Input: grid = 
> [[1, 1, 1],
>  [1, 1, 1],
>  [1, 1, 1]]
> Output: 9
> Explanation: There are four 2x2 rectangles, four 2x3 and 3x2 rectangles, and one 3x3 rectangle.
>  
> 
> Example 3:
> 
> Input: grid = 
> [[1, 1, 1, 1]]
> Output: 0
> Explanation: Rectangles must have four distinct corners.
>  
> 
> Note:
> 
> The number of rows and columns of grid will each be in the range [1, 200].
> Each grid[i][j] will be either 0 or 1.
> The number of 1s in the grid will be at most 6000.


Solution:
```java
// Time O(m ^ 2 * n), m, n = grid.length, grid[0].length
// Space O(1)

// Fix 2 rows first, then scan column by column
// count the #columns with 1s, then do C(n, 2) = (n - 1) * n / 2
public int countCornerRectangles(int[][] grid) {
    int res = 0;
    for (int i = 0; i < grid.length - 1; i++)
        for (int j = i + 1; j < grid.length; j++) {
            int cnt = 0;
            for (int k = 0; k < grid[0].length; k++)
                if (grid[i][k] == 1 && grid[j][k] == 1)
                    cnt++;
            res += (cnt - 1) * cnt / 2;                    
        }
    return res;
}
```


## H Index II

[Problem URL](https://leetcode.com/problems/h-index-ii/)

Description: 

> Follow up for H-Index: What if the citations array is sorted in ascending order? Could you optimize your algorithm?


Description of H-Index:

> Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.
> 
> According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N âˆ’ h papers have no more than h citations each."
> 
> For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3.
> 
> Note: If there are several possible values for h, the maximum one is taken as the h-index.

Solution:

Since the array is sorted, we have the searching space. The purpose is to search for the first index such that citations[index] >= length - index. The smaller the index is, the larger h (length - index) is.

```java
public int hIndex(int[] citations) {
    // search for the first index that
    // citations[index] >= length - index
    // the smaller the index is, the larger h (length - index) is 
    int length = citations.length;
    if (length == 0) {
        return 0;
    }
    // the searching space
    int lo = 0, hi = length - 1;
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (citations[mid] < length - mid) {
            // the number of papers with at least citations[mid] citations
            // is larger than citations[mid], need larger mid and
            // smaller (length - mid), go to the right side
            lo = mid + 1;
        } else {
            // go to the left side, find the smallest possible mid
            hi = mid;
        }
    }
    if (citations[lo] >= length - lo) {
        return length - lo;
    } else {
        return 0;
    }
}
```


## Prefix And Suffix Search

[Problem URL](https://leetcode.com/problems/prefix-and-suffix-search)

Description:

> Given many words, words[i] has weight i.
> 
> Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.
> 
> Examples:
> Input:
> WordFilter(["apple"])
> WordFilter.f("a", "e") // returns 0
> WordFilter.f("b", "") // returns -1
> Note:
> words has length in range [1, 15000].
> For each test case, up to words.length queries WordFilter.f may be made.
> words[i] has length in range [1, 10].
> prefix, suffix have lengths in range [0, 10].
> words[i] and prefix, suffix queries consist of lowercase letters only.


Solution1:
```java
class WordFilter {
    // Time:
    // WordFilter: O(n * l ^ 2)
    // f: O(1)
    // Space = O(n * l ^ 2)
    Map<String, Integer> map = new HashMap<>();

    public WordFilter(String[] words) {
        for(int w = 0; w < words.length; w++){
            for(int i = 0; i <= 10 && i <= words[w].length(); i++){
                for(int j = 0; j <= 10 && j <= words[w].length(); j++){
                    map.put(words[w].substring(0, i) + "#" + words[w].substring(words[w].length()-j), w);
                }
            }
        }
    }

    public int f(String prefix, String suffix) {
        return (map.containsKey(prefix + "#" + suffix))? map.get(prefix + "#" + suffix) : -1;
    }
}

/**
 * Your WordFilter object will be instantiated and called as such:
 * WordFilter obj = new WordFilter(words);
 * int param_1 = obj.f(prefix,suffix);
 */
```



Solution2
```java
class WordFilter {
    // Time:
    // WordFilter(), O(n * l ^ 2), n is words.length, l is max length of a word
    // f(), O(l)
    // Space:
    // O(n * l ^ 2), size of the trie
    
    class TrieNode {
        Map<Character, TrieNode> children;
        int weight;
        
        public TrieNode() {
            children = new HashMap<>();
            weight = -1;
        }
    }
    
    TrieNode root;
    
    public WordFilter(String[] words) {
        root = new TrieNode();
        // for each suffix of the word
        // insert the suffix followed by "#" and the word into Trie
        for (int i = 0; i < words.length; i++) {
            String word = words[i] + "#";
            for (int j = 0; j < word.length(); j++) {
                TrieNode curr = root;
                curr.weight = i;
                // e.g., word[i] is apple, word is apple# 
                // longest will be apple#apple (2 * word.length() - 1)
                for (int k = j; k < 2 * word.length() - 1; k++) {
                    char c = word.charAt(k % word.length());
                    if (!curr.children.containsKey(c))
                        curr.children.put(c, new TrieNode());
                    curr = curr.children.get(c);
                    curr.weight = i;
                }
            }
        }
    }
    
    public int f(String prefix, String suffix) {
        TrieNode curr = root;
        for (char c : (suffix + "#" + prefix).toCharArray()) {
            if (!curr.children.containsKey(c))
                return -1;
            curr = curr.children.get(c);
        }
        return curr.weight;
    }
}

/**
 * Your WordFilter object will be instantiated and called as such:
 * WordFilter obj = new WordFilter(words);
 * int param_1 = obj.f(prefix,suffix);
 */
```



## Largest Plus Sign

[Problem URL](https://leetcode.com/problems/largest-plus-sign)

Description:

> In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0. What is the largest axis-aligned plus sign of 1s contained in the grid? Return the order of the plus sign. If there is none, return 0.
> 
> An "axis-aligned plus sign of 1s of order k" has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s. This is demonstrated in the diagrams below. Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.
> 
> Examples of Axis-Aligned Plus Signs of Order k:
> 
> Order 1:
> 000
> 010
> 000
> 
> Order 2:
> 00000
> 00100
> 01110
> 00100
> 00000
> 
> Order 3:
> 0000000
> 0001000
> 0001000
> 0111110
> 0001000
> 0001000
> 0000000
> 
> Example 1:
> 
> Input: N = 5, mines = [[4, 2]]
> Output: 2
> Explanation:
> 11111
> 11111
> 11111
> 11111
> 11011
> In the above grid, the largest plus sign can only be order 2.  One of them is marked in bold.
> 
> Example 2:
> 
> Input: N = 2, mines = []
> Output: 1
> Explanation:
> There is no plus sign of order 2, but there is of order 1.
> 
> Example 3:
> 
> Input: N = 1, mines = [[0, 0]]
> Output: 0
> Explanation:
> There is no plus sign, so return 0.
> 
> Note:
> 
>     N will be an integer in the range [1, 500].
>     mines will have length at most 5000.
>     mines[i] will be length 2 and consist of integers in the range [0, N-1].
>     (Additionally, programs submitted in C, C++, or C# will be judged with a slightly smaller time limit.)

Solution1:
Time O(N ^ 2), Space O(N ^ 2)
```java
public int orderOfLargestPlusSign(int N, int[][] mines) {
    // dp[i][j] = min length of 1s in the 4 directions
    int[][] dp = new int[N][N];
    // initialization, set to be large enough values
    for (int i = 0; i < N; i++)
        Arrays.fill(dp[i], N);
    // set the 0
    for (int[] mine : mines)
        dp[mine[0]][mine[1]] = 0;
    for (int i = 0; i < N; i++) {
        int l = 0, r = 0, u = 0, d = 0;
        for (int j = 0, k = N - 1; j < N && k >= 0; j++, k--) {
            // check left and right
            dp[i][j] = Math.min(dp[i][j], l = (dp[i][j] == 0 ? 0 : l + 1));
            dp[i][k] = Math.min(dp[i][k], r = (dp[i][k] == 0 ? 0 : r + 1));
            // check up and down
            dp[j][i] = Math.min(dp[j][i], u = (dp[j][i] == 0 ? 0 : u + 1));
            dp[k][i] = Math.min(dp[k][i], d = (dp[k][i] == 0 ? 0 : d + 1));
        }
    }
    int res = 0;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            res = Math.max(res, dp[i][j]);
    return res;
}
```


## Task Scheduler

[Problem URL](https://leetcode.com/problems/task-scheduler)

Description:

> Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.
> 
> However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.
> 
> You need to return the least number of intervals the CPU will take to finish all the given tasks.
> 
> Example 1:
> 
> Input: tasks = ["A","A","A","B","B","B"], n = 2
> Output: 8
> Explanation: A -> B -> idle -> A -> B -> idle -> A -> B.
> 
> Note:
> 
>     The number of tasks is in the range [1, 10000].
>     The integer n is in the range [0, 100].


Solution1:
Arrange the most frequent task first.
```java
// Time O(n)
// Space O(1)
public int leastInterval(char[] tasks, int n) {
    int len = tasks.length;
    int[] freq = new int[26];
    int maxFreq = 0, maxNum = 0;
    for (char c : tasks) {
        freq[c - 'A']++;
        if (freq[c - 'A'] > maxFreq) {
            maxFreq = freq[c - 'A'];
            maxNum = 1;
        } else if (freq[c - 'A'] == maxFreq) {
            maxNum++;
        }
    }
    // case1, no idles
    // case2, there will be idles,
    // (most freq - 1) * (cooling + task itself) + last part (all task with same max freq)
    return Math.max(len, (maxFreq - 1) * (n + 1) + maxNum);
}
```


Solution2:
```java
// Time O(n)
// Space O(1)
public int leastInterval(char[] tasks, int n) {
    int len = tasks.length;
    int[] freq = new int[26];
    int maxFreq = 0, maxNum = 0;
    for (char c : tasks) {
        freq[c - 'A']++;
        if (freq[c - 'A'] > maxFreq) {
            maxFreq = freq[c - 'A'];
            maxNum = 1;
        } else if (freq[c - 'A'] == maxFreq) {
            maxNum++;
        }
    }
    // case1, no idles
    // case2, there will be idles,
    // (most freq - 1) * (cooling + task itself) + last part (all task with same max freq)
    return Math.max(len, (maxFreq - 1) * (n + 1) + maxNum);
}
```


## Maximum Sum of 3 Non-Overlapping Subarrays

[Problem URL](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)

Description:

> In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.
> 
> Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.
> 
> Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.
> 
> Example:
> 
> Input: [1,2,1,2,6,7,5,1], 2
> Output: [0, 3, 5]
> Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
> We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
> 
> Note:
> nums.length will be between 1 and 20000.
> nums[i] will be between 1 and 65535.
> k will be between 1 and floor(nums.length / 3).

Solution1:
```java
// Time O(n)
// Space O(n)
public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
    int n = nums.length, maxsum = 0;
    // posLeft[i] is the starting index for the left interval in range [0, i];
    // posRight[i] is the starting index for the right interval in range [i, n - 1];
    int[] sum = new int[n + 1], posLeft = new int[n], posRight = new int[n], res = new int[3];
    // sum[i + 1] = sums up to nums[i]
    for (int i = 0; i < n; i++)
        sum[i + 1] = sum[i] + nums[i];
    // DP for starting index of the left max sum interval
    for (int i = k, tot = sum[k] - sum[0]; i < n; i++) {
        // first interval is initialized as 0..k - 1
        // i is the ending index of first interval
        // starts i + 1 - k, ends i
        // tot is the summation of the first interval
        
        // if adding nums[i] makes it bigger, update
        if (sum[i + 1] - sum[i + 1 - k] > tot) {
            posLeft[i] = i + 1 - k;
            tot = sum[i + 1] - sum[i + 1 - k];
        }
        else
            posLeft[i] = posLeft[i - 1];
    }
    // DP for starting index of the right max sum interval
    // caution: the condition is ">= tot" for right interval, and "> tot" for left interval
    // Because if there are multiple answers, return the lexicographically smallest one.
    posRight[n - k] = n - k;
    for (int i = n - k - 1, tot = sum[n] - sum[n - k]; i >= 0; i--) {
        if (sum[i + k] - sum[i] >= tot) {
            posRight[i] = i;
            tot = sum[i + k] - sum[i];
        }
        else
            posRight[i] = posRight[i + 1];
    }
    // test all possible middle interval
    // i is the starting index of the middle interval
    for (int i = k; i <= n - 2 * k; i++) {
        int l = posLeft[i - 1], r = posRight[i + k];
        int tot = (sum[i + k] - sum[i]) + (sum[l + k] - sum[l]) + (sum[r + k] - sum[r]);
        if (tot > maxsum) {
            maxsum = tot;
            res[0] = l;
            res[1] = i;
            res[2] = r;
        }
    }
    return res;
}
```

Solution2:
```java
// Time O(n)
// Space O(n)
public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
    int[] res = new int[3];
    if (nums == null || k <= 0 || nums.length < 3 * k) {
        return res;
    }
    int n = nums.length;
    int[] sums = new int[n + 1];
    // store accumulative summations
    // sums[i] = summations up to nums[i - 1]
    for (int i = 1; i <= n; i++)
        sums[i] = sums[i - 1] + nums[i - 1];
    // dp[i][j] = in i th sum, the max non-overlap sum we can have from 0 to j - 1
    // idx[i][j] = in i th sum, the first starting index for that sum.
    int[][] dp = new int[4][n + 1];
    int[][] idx = new int[4][n + 1];

    for (int i = 1; i <= 3; i++) {
        // note, here position is off by 1
        for (int j = k * i; j <= n; j++) {
            // previous subarray ends at j - k - 1
            // current subarray starts at j - k, ends at j - 1
            // initial, curr sum = cumulative sum nums[j - k]...nums[j - 1] + max sum of previous subarray
            int curSum = sums[j] - sums[j - k] + dp[i - 1][j - k];
            // if adding nums[j - 1] makes it bigger, update
            if (curSum > dp[i][j - 1]) {
                dp[i][j] = curSum;
                idx[i][j] = j - k;
            } else {
                // adding nums[j - 1] doesn't make it bigger, inherit preious result
                dp[i][j] = dp[i][j - 1];
                idx[i][j] = idx[i][j - 1];              
            }
        }
    }
    // index = ending index of a subarray - 1
    int index = n;
    for (int i = 2; i >= 0; i--) {
        res[i] = idx[i + 1][index];
        index = res[i];
    }
    return res;
}
```


## First Bad Version

[Problem URL](https://leetcode.com/problems/first-bad-version)

Description:

> You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
> 
> Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.
> 
> You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Solution:
```java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */
// Time O(logn)
// Space O(1)
public int firstBadVersion(int n) {
    int l = 1, r = n;
    while (l < r) {
        int mid = l + (r - l) / 2;
        if (isBadVersion(mid)) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }
    return l;
}
```


## Binary Search Tree Iterator

[Problem URL](https://leetcode.com/problems/binary-search-tree-iterator/)

Description:

> Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
> 
> Calling next() will return the next smallest number in the BST.
> 
> Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.


Solution:
Based on BST's inorder traversal

```java
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

// Time:
// hasNext() O(1), next() O(h)
// Space O(h)
public class BSTIterator {
    private Stack<TreeNode> stack;
    private TreeNode curr;
    
    public BSTIterator(TreeNode root) {
        curr = root;
        stack = new Stack<>();
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return (curr != null || !stack.isEmpty());
    }

    /** @return the next smallest number */
    public int next() {
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        TreeNode node = curr;
        curr = curr.right;
        return node.val;
    }
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
```


## Valid Palindrome

[Problem URL](https://leetcode.com/problems/valid-palindrome)

Description:

> Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
> 
> For example,
> "A man, a plan, a canal: Panama" is a palindrome.
> "race a car" is not a palindrome.
> 
> Note:
> Have you consider that the string might be empty? This is a good question to ask during an interview.
> 
> For the purpose of this problem, we define empty string as valid palindrome.

Solution:
Time O(n), space O(1)
```java
// Time O(n)
// Space O(1)
public boolean isPalindrome(String s) {
    if (s == null || s.isEmpty())
        return true;
    int i = 0, j = s.length() - 1;
    char cHead, cTail;
    while (i <= j) {
        cHead = s.charAt(i);
        cTail = s.charAt(j);
        if (!Character.isLetterOrDigit(cHead))
            i++;
        else if (!Character.isLetterOrDigit(cTail))
            j--;
        else {
            if (Character.toLowerCase(cHead) != Character.toLowerCase(cTail))
                return false;
            i++;
            j--;
        }
    }
    return true;
}
```


## Valid Palindrome II

[Problem URL](https://leetcode.com/problems/valid-palindrome-ii)

Description:

> Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.
> 
> Example 1:
> Input: "aba"
> Output: True
> Example 2:
> Input: "abca"
> Output: True
> Explanation: You could delete the character 'c'.
> Note:
> The string will only contain lowercase characters a-z. The maximum length of the string is 50000.

```java
// Time O(n), at most two checks O(n)
// Space O(1)
public boolean validPalindrome(String s) {
    int i = 0, j = s.length() - 1;
    while (i < j) {
        // find different letters
        // before that s[0..i - 1] and s[j + 1..n - 1] form a palindrome
        if (s.charAt(i) != s.charAt(j))
            // check s[i + 1..j] or s[i..j - 1] forms a palindrome
            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1);
        i++;
        j--;
    }
    // no different letters, s itself is a palindrome
    return true;
}

private boolean isPalindrome(String s, int i, int j) {
    while (i < j) {
        if (s.charAt(i) != s.charAt(j))
            return false;
        i++;
        j--;
    }
    return true;
}
```

## Add And Search Word Data Structure Design

[Problem URL](https://leetcode.com/problems/add-and-search-word-data-structure-design)

Description:

Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

For example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
Note:
You may assume that all words are consist of lowercase letters a-z.

Solution:
```java
// Time:
// WordDictionary(), O(1)
// addWord(), O(n)
// search(), O(26 ^ n)
// Space: O(n)
public class WordDictionary {
    private static class TrieNode {
        TrieNode[] children = new TrieNode[26];
        String word = "";
    }
    private TrieNode root;
    /** Initialize your data structure here. */
    public WordDictionary() {
        root = new TrieNode();
    }
    
    /** Adds a word into the data structure. */
    public void addWord(String word) {
        TrieNode node = root;
        for (char c: word.toCharArray()) {
            if (node.children[c - 'a'] == null)
                node.children[c - 'a'] = new TrieNode();
            node = node.children[c - 'a'];
        }
        node.word = word;
    }
    
    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
    public boolean search(String word) {
        return match(word.toCharArray(), 0, root);   
    }
    
    private boolean match(char[] chars, int idx, TrieNode node) {
        if (idx == chars.length)
            return !node.word.equals("");
        if (chars[idx] != '.')
            return node.children[chars[idx] - 'a'] != null
            && match(chars, idx + 1, node.children[chars[idx] - 'a']);
        else {
            for (int i = 0; i < node.children.length; i++)
                if (node.children[i] != null
                    && match(chars, idx + 1, node.children[i]))
                    return true;
        }
        return false;
    }
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
```


## Merge Intervals

[Problem URL](https://leetcode.com/problems/merge-intervals)

Description:

Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].


Solution:
```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
// Time O(nlogn)
// Space O(1)
public List<Interval> merge(List<Interval> intervals) {
    List<Interval> res = new ArrayList<Interval>();
    if (intervals == null || intervals.size() == 0) {
        return res;
    }
    Collections.sort(intervals, (inv1, inv2) -> (inv1.start - inv2.start));
    int s = intervals.get(0).start;
    int e = intervals.get(0).end;
    for (int i = 1; i < intervals.size(); i++) {
        Interval curr = intervals.get(i);
        if (curr.start <= e) {
            // Overlapping intervals, move the end if needed
            e = Math.max(e, curr.end);
        } else {
            // Disjoint intervals, add the previous one and reset bounds
            res.add(new Interval(s, e));
            s = curr.start;
            e = curr.end;
        }
    }
    // Add the last interval
    res.add(new Interval(s, e));
    return res;
}
```


## Two Sum

[Problem URL](https://leetcode.com/problems/two-sum)

Description:

> Given an array of integers, return indices of the two numbers such that they add up to a specific target.
> 
> You may assume that each input would have exactly one solution, and you may not use the same element twice.
> 
> Example:
> 
> Given nums = [2, 7, 11, 15], target = 9,
> 
> Because nums[0] + nums[1] = 2 + 7 = 9,
> return [0, 1].

Solution:
Time O(n), space O(n)
```java
// Time O(n)
// Space O(n)
public int[] twoSum(int[] nums, int target) {
    int[] res = new int[2];
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(target - nums[i])) {
            res[1] = i;
            res[0] = map.get(target - nums[i]);
            return res;
        }
        map.put(nums[i], i);
    }
    return res;
}
```


## Exclusive Time Of Functions

[Problem URL](https://leetcode.com/problems/exclusive-time-of-functions)

Description:

> Given the running logs of n functions that are executed in a nonpreemptive single threaded CPU, find the exclusive time of these functions.
> 
> Each function has a unique id, start from 0 to n-1. A function may be called recursively or by another function.
> 
> A log is a string has this format : function_id:start_or_end:timestamp. For example, "0:start:0" means function 0 starts from the very beginning of time 0. "0:end:0" means function 0 ends to the very end of time 0.
> 
> Exclusive time of a function is defined as the time spent within this function, the time spent by calling other functions should not be considered as this function's exclusive time. You should return the exclusive time of each function sorted by their function id.
> 
> Example 1:
> 
> Input:
> n = 2
> logs = 
> ["0:start:0",
>  "1:start:2",
>  "1:end:5",
>  "0:end:6"]
> Output:[3, 4]
> Explanation:
> Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. 
> Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.
> Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. 
> So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.
> 
> Note:
> 
>     Input logs will be sorted by timestamp, NOT log id.
>     Your output should be sorted by function id, which means the 0th element of your output corresponds to the exclusive time of function 0.
>     Two functions won't start or end at the same time.
>     Functions could be called recursively, and will always end.
>     1 <= n <= 100


Solution:
Use stack, push functions when "start", pop when "end"
Time O(n)
Space O(n), worst case, begin with all "starts"
```java
// Time O(n)
// Space O(n)
public int[] exclusiveTime(int n, List<String> logs) {
    int[] res = new int[n];
    Stack<Integer> funcs = new Stack<>();
    // start of the interval
    int start = 0;
    for (String log : logs) {
        String[] line = log.split(":");
        int time = Integer.parseInt(line[2]);
        if (line[1].equals("start")) {
            if (!funcs.isEmpty())
                // line[2] is the start of next interval,
                // doesn't belong to this interval
                res[funcs.peek()] += time - start;
            funcs.push(Integer.parseInt(line[0]));
            start = time;
        } else {
            // here line[2] is the end of current interval, so +1
            res[funcs.pop()] += time - start + 1;
            // start of next interval
            start = time + 1;
        }
    }
    return res;
}
```


## Flatten Nested List Iterator

[Problem URL](https://leetcode.com/problems/flatten-nested-list-iterator)

Description:

> Given a nested list of integers, implement an iterator to flatten it.
> 
> Each element is either an integer, or a list -- whose elements may also be integers or other lists.
> 
> Example 1:
> Given the list [[1,1],2,[1,1]],
> 
> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].
> 
> Example 2:
> Given the list [1,[4,[6]]],
> 
> By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].


Solution:
Time O(depth * average #child)
Space O(depth * average #child)
```java
/**
 * // This is the interface that allows for creating nested lists.
 * // You should not implement it, or speculate about its implementation
 * public interface NestedInteger {
 *
 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.
 *     public boolean isInteger();
 *
 *     // @return the single integer that this NestedInteger holds, if it holds a single integer
 *     // Return null if this NestedInteger holds a nested list
 *     public Integer getInteger();
 *
 *     // @return the nested list that this NestedInteger holds, if it holds a nested list
 *     // Return null if this NestedInteger holds a single integer
 *     public List<NestedInteger> getList();
 * }
 */
Stack<NestedInteger> stack = new Stack<>();
public NestedIterator(List<NestedInteger> nestedList) {
    for (int i = nestedList.size() - 1; i >= 0; i--)
        stack.push(nestedList.get(i));
}

@Override
public Integer next() {
    return stack.pop().getInteger();
}

@Override
public boolean hasNext() {
    while (!stack.isEmpty()) {
        NestedInteger curr = stack.peek();
        if (curr.isInteger())
            return true;
        // if contains a list
        stack.pop();
        // go inside the list
        for (int i = curr.getList().size() - 1; i >= 0; i--)
            stack.push(curr.getList().get(i));
    }
    return false;
}

/**
 * Your NestedIterator object will be instantiated and called as such:
 * NestedIterator i = new NestedIterator(nestedList);
 * while (i.hasNext()) v[f()] = i.next();
 */
```


## Multiply Strings

[Problem URL](https://leetcode.com/problems/multiply-strings)

Description:

> Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.
> 
> Note:
> 
> The length of both num1 and num2 is < 110.
> Both num1 and num2 contains only digits 0-9.
> Both num1 and num2 does not contain any leading zero.
> You must not use any built-in BigInteger library or convert the inputs to integer directly.


Solution:
```java
// time O(m * n), m, n = num1.length, num2.length
// space O(m + n)
public String multiply(String num1, String num2) {
    int m = num1.length(), n = num2.length();
    int[] res = new int[m + n];
    for (int i = m - 1; i >= 0; i--)
        for (int j = n - 1; j >= 0; j--) {
            int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
            // positions the multiplications will be placed on
            int pos1 = i + j, pos2 = i + j + 1;
            int currSum = res[pos2] + mul;
            res[pos1] += currSum / 10;
            res[pos2] = currSum % 10;
        }
    StringBuilder sb = new StringBuilder();
    for (int num : res)
        // ignore leading 0s
        if (!(sb.length() == 0 && num == 0))
            sb.append(num);
    return sb.length() == 0 ? "0" : sb.toString();
}
```


## Validate Binary Search Tree

[Problem URL](https://leetcode.com/problems/validate-binary-search-tree)

Description:

> Given a binary tree, determine if it is a valid binary search tree (BST).
> 
> Assume a BST is defined as follows:
> 
> The left subtree of a node contains only nodes with keys less than the node's key.
> The right subtree of a node contains only nodes with keys greater than the node's key.
> Both the left and right subtrees must also be binary search trees.
> Example 1:
> Binary tree [2,1,3], return true.
> 
> Example 2:
> Binary tree [1,2,3], return false.


Solution1:
```java
// inorder traversal
// Time O(n)
// Space O(h), worst case O(n)
public class Solution {
    public boolean isValidBST(TreeNode root) {
       TreeNode pre = null;
        TreeNode p = root.right;
        System.out.println(p.val);
        while (root != null)
            if (p.val <= root.val) {
                root = root.left;
            } else {
                pre = root;
                root = root.right;
            }
        return false;
    }
}
```


Solution2:

```java
// Time O(n)
// Space O(h), worst case O(n)
public class Solution {
    public boolean isValidBST(TreeNode root) {
        return helper(root, (long)Integer.MIN_VALUE - 1, (long)Integer.MAX_VALUE + 1);
    }
    
    private boolean helper(TreeNode root, long minVal, long maxVal) {
        if (root == null) {
            return true;
        }
        if (root.val <= minVal || root.val >= maxVal) {
            return false;
        }
        return helper(root.left, minVal, root.val) && helper(root.right, root.val, maxVal);
    }
}
```


## Valid Parentheses

[Problem URL](https://leetcode.com/problems/valid-parentheses)

Description:

Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

```java
// Time O(n)
// space O(n)
public boolean isValid(String s) {
    if (s.length() % 2 != 0)
        return false;
    Stack<Character> stack = new Stack<Character>();
    for (char c : s.toCharArray()) {
        if (c == '(')
            stack.push(')');
        else if (c == '{')
            stack.push('}');
        else if (c == '[')
            stack.push(']');
        else if (stack.isEmpty() || stack.pop() != c)
            // for close ones, if not the same, then not a pair
            return false;
    }
    return stack.isEmpty();
}
```


## Find Maximim Sum With Size K

Description:

> Given an array of integers and a number k, find maximum sum of a subarray of size k.

```java
// Time O(n)
// Space O(1)
public int maxSum(int arr[], int k) {
    // k must be greater
    int n = nums.length;
    if (n < k) {
       return -1;
    }
    // Compute sum of first window of size k
    int res = 0;
    for (int i = 0; i < k; i++)
       res += nums[i];
    // Compute sums of remaining windows by
    // removing first element of previous
    // window and adding last element of 
    // current window.
    int currSum = res;
    for (int i = k; i < n; i++) {
       currSum += nums[i] - nums[i - k];
       res = Math.max(res, currSum);
    }
    return res;
}
```


## Distinct Subsequences

[Problem URL](https://leetcode.com/problems/distinct-subsequences)

Description:

Given a string S and a string T, count the number of distinct subsequences of S which equals T.

A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

Here is an example:
S = "rabbbit", T = "rabbit"

Return 3.

Solution1:
```java
// Time O(m * n)
// Space O(m * n)
public int numDistinct(String s, String t) {
    int n = s.length(), m = t.length();
    // dp[i][j] = #times s[0..j - 1] contains t[0..i - 1] as sub sequences
    int[][] dp = new int[m + 1][n + 1];
    // first row is all 1, because empty string is a
    // subsequence of any string but only 1 time. 
    for (int j = 0; j <= n; j++)
        dp[0][j] = 1;
    // the first column of every rows except the first must be 0.
    // This is because an empty string cannot contain a non-empty string as a substring
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (t.charAt(i - 1) == s.charAt(j - 1))
                // the number we had before +
                // the distinct number of subsequences we had with shorter T and shorter S.
                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];
            else
                // if the current character in S doesnâ€™t
                // equal to current character T,
                // then we have the same number of distinct
                // subsequences as we had without the new character.
                dp[i][j] = dp[i][j - 1];
        }
    }
    return dp[m][n];
}
```


Solution2:
```java
// Time O(m * n)
// Space O(n)
public int numDistinct(String s, String t) {
    int n = s.length(), m = t.length();
    // dp[i][j] = #times s[0..j - 1] contains t[0..i - 1] as sub sequences
    int[] dp = new int[n + 1];
    // first row is all 1, because empty string is a
    // subsequence of any string but only 1 time. 
    for (int j = 0; j <= n; j++)
        dp[j] = 1;
    // the first column of every rows except the first must be 0.
    // This is because an empty string cannot contain a non-empty string as a substring
    int pre = dp[0], cur; // pre = dp[i - 1][j - 1], cur = dp[i - 1][j]
    for (int i = 1; i <= m; i++) {
        pre = dp[0];
        dp[0] = 0;
        for (int j = 1; j <= n; j++) {
            // before dp[j] updated in current row,
            // so current dp[j] acts like dp[i - 1][j]
            cur = dp[j];
            if (t.charAt(i - 1) == s.charAt(j - 1))
                // the number we had before +
                // the distinct number of subsequences we had with shorter T and shorter S.
                dp[j] = pre + dp[j - 1];
            else
                // if the current character in S doesnâ€™t
                // equal to current character T,
                // then we have the same number of distinct
                // subsequences as we had without the new character.
                dp[j] = dp[j - 1];
            pre = cur;
        }
    }
    return dp[n];
}
```


## Maximum Subarray

[Problem URL](https://leetcode.com/problems/maximum-subarray/)

Description:

> Find the contiguous subarray within an array (containing at least one number) which has the largest sum.
> 
> For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
> the contiguous subarray [4,-1,2,1] has the largest sum = 6.

Solution1:
```java
// Time O(n)
// Space O(n)
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    int n = nums.length;
    //dp[i] means the maximum subarray ending with nums[i];
    int[] dp = new int[n];
    dp[0] = nums[0];
    int max = dp[0];
    
    for(int i = 1; i < n; i++){
        dp[i] = nums[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);
        max = Math.max(max, dp[i]);
    }
    
    return max;
}
```

Solution2:
```java
// Time O(n)
// Space (1)
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0)
        return 0;
    int global = nums[0], local = nums[0];
    // local(n+1) = max(nums[n], local(n) + nums[n])
    // global(n+1) = max(global(n), local(n + 1))
    for (int i = 1; i < nums.length; i++) {
        local = Math.max(nums[i], local + nums[i]);
        global = Math.max(global, local);
    }
    return global;
}
```



## Super Pow

[Problem URL](https://leetcode.com/problems/super-pow)

Description:

> Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.
> 
> Example1:
> 
> a = 2
> b = [3]
> 
> Result: 8
> Example2:
> 
> a = 2
> b = [1,0]
> 
> Result: 1024

Solution1:
```java
// One knowledge: ab % k = (a%k)(b%k)%k
// Since the power here is an array, weâ€™d better handle it digit by digit.
// One observation:
// a^1234567 % k = (a^1234560 % k) * (a^7 % k) % k = (a^123456 % k)^10 % k * (a^7 % k) % k
// Looks complicated? Let me put it other way:
// Suppose f(a, b) calculates a^b % k; Then translate above formula to using f :
// f(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k;

// Time: O(n), n = b.length
// For each digit, powmod is called twice.
// powMod is running in constant time because n should never be larger than 10, so it is O(19N) worst case.
// Space: O(n), max depth is n
public int superPow(int a, int[] b) {
    return superPow(a, b, b.length - 1, 1337);
}

public int superPow(int a, int[] b, int idx, int base) {
    if (idx < 0)
        return 1;
    int lastDigit = b[idx--];
    return powMod(superPow(a, b, idx, base), 10, base) * powMod(a, lastDigit, base) % base;
}

private int powMod(int a, int n, int base) {
    a %= base;
    int res = 1;
    for (int i = 0; i < n; i++)
        res = (res * a) % base;
    return res;
}
```


Solution2:
```java
// One knowledge: ab % k = (a%k)(b%k)%k
// Since the power here is an array, weâ€™d better handle it digit by digit.
// One observation:
// a^1234567 % k = (a^1234560 % k) * (a^7 % k) % k = (a^123456 % k)^10 % k * (a^7 % k) % k
// Looks complicated? Let me put it other way:
// Suppose f(a, b) calculates a^b % k; Then translate above formula to using f :
// f(a,1234567) = f(a, 1234560) * f(a, 7) % k = f(f(a, 123456),10) * f(a,7)%k;

// Time: O(n), n = b.length
// For each digit, powmod is called twice.
// powMod is running in constant time because n should never be larger than 10, so it is O(19N) worst case.
// Space: O(1)
public int superPow(int a, int[] b) {
    int res = 1;
    a %= 1337;
    for(int i = 0;i < b.length; i++){
        res = (powmod(res, 10) * powmod(a, b[i])) % 1337;
    }
    return res;
}

private int powmod(int r, int k) {
    int x = 1;
    for(int i = 1; i <= k; i++)
        x = (x * r) % 1337;
    return x;
}
```


## Best Time To Buy And Sell Stock II

[Problem URL](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)

Description:

> Say you have an array for which the ith element is the price of a given stock on day i.
> 
> Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

Solution:
```java
// Time O(n)
// Space O(1)
public int maxProfit(int[] prices) {
    int profit = 0;
    for (int i = 0; i < prices.length - 1; i++) {
        if (prices[i + 1] > prices[i]) {
            profit += prices[i + 1] - prices[i];
        }
    }
    return profit;
}
```


## Next Permutation

[Problem URL](https://leetcode.com/problems/next-permutation)

Description:

> Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
> 
> If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
> 
> The replacement must be in-place, do not allocate extra memory.
> 
> Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
> 1,2,3 â†’ 1,3,2
> 3,2,1 â†’ 1,2,3
> 1,1,5 â†’ 1,5,1


Solution:
```java
// Time O(n)
// Space O(1)
public void nextPermutation(int[] nums) {
    int i = nums.length - 2;
    // find the index of the first digit that < its next digit
    // e.g. 1, 2, 3,  find 2
    while (i >= 0 && nums[i + 1] <= nums[i]) {
        i--;
    }
    if (i >= 0) {
        // find the first digit that > the one we just found
        // and swap
        int j = nums.length - 1;
        while (j >= 0 && nums[j] <= nums[i]) {
            j--;
        }
        swap(nums, i, j);
    }
    // we need to place those numbers
    // in ascending order to get their smallest permutation.
    // digits on the right were already sorted in descending order.
    // reverse the rest of the num
    reverse(nums, i + 1);
}

private void reverse(int[] nums, int start) {
    int i = start, j = nums.length - 1;
    while (i < j) {
        swap(nums, i, j);
        i++;
        j--;
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```


## Previous Permutation
```java
// Time O(n)
// Space O(1)
public void nextPermutation(int[] nums) {
    int i = nums.length - 2;
    // find the index of the first digit that > its next digit
    // e.g. 1, 3, 2,  find 3
    while (i >= 0 && nums[i + 1] >= nums[i]) {
        i--;
    }
    if (i >= 0) {
        // find the first digit that < the one we just found
        // and swap
        int j = nums.length - 1;
        while (j >= 0 && nums[j] >= nums[i]) {
            j--;
        }
        swap(nums, i, j);
    }
    // we need to place those numbers
    // in DESC order to get their largest permutation.
    // digits on the right were already sorted in ASCE order.
    // reverse the rest of the num
    reverse(nums, i + 1);
}

private void reverse(int[] nums, int start) {
    int i = start, j = nums.length - 1;
    while (i < j) {
        swap(nums, i, j);
        i++;
        j--;
    }
}

private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
```


## Maximum Product Subarray

[Problem URL](https://leetcode.com/problems/maximum-product-subarray/)

Description:

> Find the contiguous subarray within an array (containing at least one number) which has the largest product.
> 
> For example, given the array [2,3,-2,4],
> the contiguous subarray [2,3] has the largest product = 6.


Solution:

```java
// Time O(n)
// Space O(1)
public int maxProduct(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    if (nums.length == 1) {
        return nums[0];
    }
    // record min because there are negative numbers in the array
    int maxLocal = nums[0], minLocal = nums[0], global = nums[0];
    for (int i = 1; i < nums.length; i++) {
        int maxCopy = maxLocal;
        maxLocal = Math.max(Math.max(maxLocal * nums[i], nums[i]), nums[i] * minLocal);
        minLocal = Math.min(Math.min(maxCopy * nums[i], nums[i]), nums[i] * minLocal);
        global = Math.max(maxLocal, global);
    }
    return global;
}
```


Solution2:
```java
// Time O(2 ^ n)
// Space O(n), max depth is n
public List<List<Integer>> subsets(int[] nums) {
    List<Integer> res = new ArrayList<>();
    backtrack(nums, res, new ArrayList<>(), 0);
    for (int n : res)
        System.out.println(n);
    return null;
}

private void backtrack(int[] nums, List<Integer> res, List<Integer> curr, int start) {
    if (!curr.isEmpty())
        res.add(curr.get(0));
    else
        res.add(0);
    for (int i = start; i < nums.length; i++) {
        if (curr.isEmpty())
            curr.add(nums[i]);
        else
            curr.set(0, curr.get(0) * nums[i]);
        backtrack(nums, res, curr, i + 1);
        if (!curr.isEmpty())
            curr.remove(curr.size() - 1);
    }
}
```



## Linked List Random Node

[Problem URL](https://leetcode.com/problems/linked-list-random-node)

Description:

> Given a singly linked list, return a random node's value from the linked list. Each node must have the same probability of being chosen.
> 
> Follow up:
> What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space?
> 
> Example:
> 
> // Init a singly linked list [1,2,3].
> ListNode head = new ListNode(1);
> head.next = new ListNode(2);
> head.next.next = new ListNode(3);
> Solution solution = new Solution(head);
> 
> // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.
> solution.getRandom();


Solution:
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    // Time O(n)
    // Space O(1)
    ListNode head;
    Random randomGenerator;
    /** @param head The linked list's head.
        Note that the head is guaranteed to be not null, so it contains at least one node. */
    public Solution(ListNode head) {
        this.head = head;
        this.randomGenerator = new Random();
    }
    
    /** Returns a random node's value. */
    public int getRandom() {
        ListNode result = null;
        ListNode current = head;
        
        for(int n = 1; current!=null; n++) {
            if (randomGenerator.nextInt(n) == 0) {
                result = current;
            }
            current = current.next;
        }
        
        return result.val;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */
```


## Boundary Of Binary Tree

[Problem URL](https://leetcode.com/problems/boundary-of-binary-tree)

Description:

> Given a binary tree, return the values of its boundary in anti-clockwise direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.
> 
> Left boundary is defined as the path from root to the left-most node. Right boundary is defined as the path from root to the right-most node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.
> 
> The left-most node is defined as a leaf node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.
> 
> The right-most node is also defined by the same way with left and right exchanged.
> 
> Example 1
> Input:
>   1
>    \
>     2
>    / \
>   3   4
> 
> Ouput:
> [1, 3, 4, 2]
> 
> Explanation:
> The root doesn't have left subtree, so the root itself is left boundary.
> The leaves are node 3 and 4.
> The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.
> So order them in anti-clockwise without duplicates and we have [1,3,4,2].
> Example 2
> Input:
>     ____1_____
>    /          \
>   2            3
>  / \          / 
> 4   5        6   
>    / \      / \
>   7   8    9  10  
>        
> Ouput:
> [1,2,4,7,8,9,10,6,3]
> 
> Explanation:
> The left boundary are node 1,2,4. (4 is the left-most node according to definition)
> The leaves are node 4,7,8,9,10.
> The right boundary are node 1,3,6,10. (10 is the right-most node).
> So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].


Solution:
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // Time O(n)
    // Space O(h)
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        List<Integer> nodes = new ArrayList<>();
        if (root == null)
            return nodes;
        nodes.add(root.val);
        leftBoundary(root.left, nodes);
        leaves(root.left, nodes);
        leaves(root.right, nodes);
        rightBoundary(root.right, nodes);

        return nodes;
    }
    
    public void leftBoundary(TreeNode root, List<Integer> nodes) {
        if (root == null || (root.left == null && root.right == null))
            return;
        nodes.add(root.val);
        if (root.left == null)
            leftBoundary(root.right, nodes);
        else
            leftBoundary(root.left, nodes);
    }
    
    public void rightBoundary(TreeNode root, List<Integer> nodes) {
        if (root == null || (root.right == null && root.left == null))
            return;
        if (root.right == null)
            rightBoundary(root.left, nodes);
        else rightBoundary(root.right, nodes);
        nodes.add(root.val); // add after child visit(reverse)
    }
    
    public void leaves(TreeNode root, List<Integer> nodes) {
        if (root == null)
            return;
        if (root.left == null && root.right == null) {
            nodes.add(root.val);
            return;
        }
        leaves(root.left, nodes);
        leaves(root.right, nodes);
    }
}
```
